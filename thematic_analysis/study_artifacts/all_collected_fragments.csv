frag_ID,repo_ID,repo_name,fragments,quality_requirements (ISO 25010),fragments_source
F001,37,baetyl/baetyl,"""Check the publishing and receiving messages via MQTTBox.""",Functional Suitability,https://baetyl.readthedocs.io/en/1.0.0/guides/Message-transfer-among-devices-with-hub-service.html#workflow
F002,37,baetyl/baetyl,"""client2 and client3 will respectively get the message from client1 published to the topic t to Hub Service.""",Reliability,https://baetyl.readthedocs.io/en/1.0.0/guides/Message-transfer-among-devices-with-hub-service.html#message-transfer-test-among-devices
F003,37,baetyl/baetyl,"""Modify the configuration according to the usage requirements, and then execute sudo systemctl start baetyl.""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Message-transfer-among-devices-with-hub-service.html#workflow
F004,37,baetyl/baetyl,"""Click the Add subscriber button to subscribe to the topic t and t/topic.""",Interaction Capability,https://baetyl.readthedocs.io/en/1.0.0/guides/Message-transfer-among-devices-with-hub-service.html#message-transfer-test-among-devices
F005,37,baetyl/baetyl,"""The specified account (depends on username/password) will have permission to all single-level legal topics of MQTT protocol.""",Security,https://baetyl.readthedocs.io/en/1.0.0/guides/Message-transfer-among-devices-with-hub-service.html#message-routing-test
F006,37,baetyl/baetyl,"""Message routing rules configuration""",Functional Suitability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-remote-mqtt
F007,37,baetyl/baetyl,"""[MUST] The Client ID for the client to connect with the local Hub.""",Functional Suitability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-remote-mqtt
F008,37,baetyl/baetyl,"""interval: The default value is 1m, means maximum interval of client reconnection, doubled from 500 microseconds to maximum.""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-remote-mqtt
F009,37,baetyl/baetyl,"""logger: The default value is `info`, log level, support `debug`, `info`, `warn` and `error`.""",Maintainability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-remote-mqtt
F010,37,baetyl/baetyl," ""address: [MUST] The endpoint address for the client to connect with the local Hub.""",Flexibility,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-remote-mqtt
F011,37,baetyl/baetyl,"""ca, key, cert: Paths for authentication.""","Flexibility, Security",https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-function-node
F012,37,baetyl/baetyl,"""restart: Service restart policy configuration""",Reliability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F013,37,baetyl/baetyl,"""backoff: min/max interval of restart""",Reliability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F014,37,baetyl/baetyl,"""cpu: cpus: The percentage of CPU available of the service instance""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F015,37,baetyl/baetyl,"""memory: limit: The available memory of the service""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F016,37,baetyl/baetyl,"""replica: The number of service copies, indicating the number of service instances started.""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F017,37,baetyl/baetyl,"""readonly: whether the storage volume is read-only""",Security,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F018,37,baetyl/baetyl,"""path: The path of the storage volume on the host""",Security,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F019,37,baetyl/baetyl,"""args: Service instance startup arguments""",Maintainability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F020,37,baetyl/baetyl,"""volumes: Storage volume list""",Maintainability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F021,37,baetyl/baetyl,"""image: Service entry. In the docker container mode, which means the address of image.""",Flexibility,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#application-configuration
F022,37,baetyl/baetyl,"""logger: Logger configuration""",Interaction Capability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F023,37,baetyl/baetyl,"""retry: interval: 20s, means the re-publish interval of message.""",Reliability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F024,37,baetyl/baetyl,"""shutdown: Service exit configuration, timeout: 10m""",Reliability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F025,37,baetyl/baetyl,"""logger: backup: max: 15, the maximum number of log files to keep.""",Reliability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F026,37,baetyl/baetyl,"""certificate: SSL/TLS certificate authentication configuration, if ssl or wss is enabled, it must be configured.""",Security,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F027,37,baetyl/baetyl,"""principals: ACL configuration. If not configured, client cannot connect to this Hub.""",Security,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F028,37,baetyl/baetyl,"""message: length: max: 32k, maximum message length that can be transmitted.""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F029,37,baetyl/baetyl,"""ingress: buffer: size: 10000, means the number of messages that can be cached in memory with QoS 0.""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F030,37,baetyl/baetyl,"""egress: buffer: size: 100, the size of the message buffer not confirmed (ack) after QoS 1.""",Performance Efficiency,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F031,37,baetyl/baetyl,"""storage: dir: var/db/baetyl/data, database storage directory.""",Maintainability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F032,37,baetyl/baetyl,"""status: logging: enable: false, interval: 60s""",Maintainability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F033,37,baetyl/baetyl,"""logger: format: text or json, log print format.""",Flexibility,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F034,37,baetyl/baetyl,"""listen: [MUST] Listening address.""",Flexibility,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F035,37,baetyl/baetyl,"""subscriptions: Topic routing configuration""",Interaction Capability,https://baetyl.readthedocs.io/en/1.0.0/guides/Config-interpretation.html#baetyl-hub
F036,95,fledge-iot/fledge,"""Fledge is implemented as a collection of microservices which include: Core services, Data transformation and alerting services, South services, North services, Edge data processing applications, Event detection and notification, Set point control.""",Flexibility; Maintainability,https://fledge-iot.readthedocs.io/en/latest/introduction.html?highlight=overview#architectural-overview
F037,95,fledge-iot/fledge,"""Fledge services may also be customized by creating new plugins, written in C/C++ or Python, for data collection, processing, export, rule evaluation and event notification.""",Flexibility; Maintainability,https://fledge-iot.readthedocs.io/en/latest/introduction.html?highlight=overview#architectural-overview
F038,95,fledge-iot/fledge,"""The type of storage engine is pluggable... SQLite may be chosen for a small footprint, Postgresql for larger installations, or in-memory storage for micro installations.""",Compatibility,https://fledge-iot.readthedocs.io/en/latest/fledge_architecture.html#storage-layer
F039,95,fledge-iot/fledge,"""South microservices offer bi-directional communication of data and metadata between Edge devices, such as sensors, actuators or PLCs and Fledge. Smaller systems may have this service installed onboard Edge devices.""",Performance Efficiency,https://fledge-iot.readthedocs.io/en/latest/fledge_architecture.html#south-microservices
F040,95,fledge-iot/fledge,"""Core functionality includes: Monitoring (to detect unresponsive microservices and self-heal), Audit Logging (to maintain logs of system changes), Certificate Storage (to maintain security certificates for different components), User Management (for authentication and permissions).""",Security,https://fledge-iot.readthedocs.io/en/latest/fledge_architecture.html#fledge-core
F041,95,fledge-iot/fledge,"""North microservices offer bi-directional communication of data and metadata between the Fledge platform and larger systems located locally or in the cloud.""",Compatibility,https://fledge-iot.readthedocs.io/en/latest/fledge_architecture.html#north-microservices
F042,95,fledge-iot/fledge,"""Fledge system backup and restore functionality.""",Reliability,https://fledge-iot.readthedocs.io/en/latest/fledge_architecture.html#fledge-core
F043,130,jomjol/AI-on-the-edge-device,"""Although a board looks similar, it can have major differences, e.g.: Processor, RAM, Flashrom, Camera Modules, Onboard/External Antenna, etc.""",Compatibility,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F044,130,jomjol/AI-on-the-edge-device,"""This can cause different Power Consumption, Power Requirements, compatibility issues, etc.""",Compatibility,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F045,130,jomjol/AI-on-the-edge-device,"""Most manufacturers and sellers buy what's cheap today on the Asian markets... trial and error approach which ESP32-CAM Module works reliably.""",Reliability,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F046,130,jomjol/AI-on-the-edge-device,"""The experience with the camera only is based on single modules... it is well possible, that this module had a damage overall and other modules of the same type will work""",Reliability,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F047,130,jomjol/AI-on-the-edge-device,"""Filter out the Number '9', as '3' will often be misread for a '9' and void every number between 3 and 9 due to it being negative flow.""",Reliability,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F048,130,jomjol/AI-on-the-edge-device,"""Split the readings into two, while the decimal numbers might move too fast to be recognized, at least the slower moving part will produce a correct reading.""",Reliability,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F049,130,jomjol/AI-on-the-edge-device,"""The ESP32-CAM supports an external antenna. It requires some soldering skills but can improve the connection quality.""",Maintainability,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F050,130,jomjol/AI-on-the-edge-device,""" ""fake"" chips, or maybe wrongly configured ESP32 Boards. """,Maintainability,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F051,130,jomjol/AI-on-the-edge-device,"""This can be done wherever the data ends up being sent, like home assistant using sensor templates.""",Maintainability,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F052,130,jomjol/AI-on-the-edge-device,"""This Project needs at least 4MB RAM!""",Performance Efficiency,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F053,130,jomjol/AI-on-the-edge-device,"""Especially the PSRAM is sometimes labeled wrong (Label: 4MB, Real: only 2 MB --> will not work!).""",Performance Efficiency,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F054,130,jomjol/AI-on-the-edge-device," ""Smaller cards (up to 4 GB) tend to be more stable and larger cards have more problems.""",Performance Efficiency,https://jomjol.github.io/AI-on-the-edge-device-docs/Hardware-Compatibility/
F055,130,jomjol/AI-on-the-edge-device,"""If you are using a low resolution and only digital mode, processing can often be done in <1 minute.""",Performance Efficiency,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F056,130,jomjol/AI-on-the-edge-device,"""Check the logs to confirm how fast it is and then set the interval accordingly under 'Expert mode' in configuration, as the normal mode will lock you to 3+ minutes.""",Performance Efficiency,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F057,130,jomjol/AI-on-the-edge-device,"""Move the Camera as close as possible (~4cm)... focus can be adjusted by turning the outer black ring of the camera.""",Interaction Capability,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F058,130,jomjol/AI-on-the-edge-device,"""Change the ImageSize to QVGA under 'Expert mode' configuration when close enough, this will be faster and is often good enough for digital recognition.""",Interaction Capability,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F059,130,jomjol/AI-on-the-edge-device,"""Try to get rid of the reflections by rotating the camera, so that the reflections are at positions where no number is.""",Interaction Capability,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F060,130,jomjol/AI-on-the-edge-device,"""If the LED reflections are too strong, put tape over the LED to diffuse the light.""",Flexibility,https://jomjol.github.io/AI-on-the-edge-device-docs/Best-Practice/
F061,138,kubeedge/kubeedge,"""A module registered with beehive can communicate with other beehive modules if the name with which other beehive module is registered or the name of the group of the module is known.""",Compatibility,https://kubeedge.io/docs/architecture/beehive/#beehive-overview
F062,138,kubeedge/kubeedge,"""Beehive supports following message operations: Send to a module/group, Receive by a module, Send Sync to a module/group, Send Response to a sync message.""",Compatibility,https://kubeedge.io/docs/architecture/beehive/#beehive-overview
F063,138,kubeedge/kubeedge,"""channels: channels is a map of string(key) which is name of module and chan(value) of message which will used to send message to the respective module.""",Compatibility,https://kubeedge.io/docs/architecture/beehive/#channel-context-structure-fields
F064,138,kubeedge/kubeedge,"""SendSync takes 3 parameters, (module, message and timeout duration).""",Performance Efficiency,https://kubeedge.io/docs/architecture/beehive/#sendsync-to-a-module
F065,138,kubeedge/kubeedge,"""If message is received before timeout, message is returned with nil error or else timeout error is returned.""",Performance Efficiency,https://kubeedge.io/docs/architecture/beehive/#sendsync-to-a-module
F066,138,kubeedge/kubeedge,"""At regular intervals (default is 20 milliseconds), check if the length of anonChannel = no of modules in that group.""",Performance Efficiency,https://kubeedge.io/docs/architecture/beehive/#sendsync-to-a-group
F067,138,kubeedge/kubeedge,"""Receive gets the channel of a module from channels map. Then it waits for a message to arrive on that channel and returns the message. Error is returned if there is any.""",Reliability,https://kubeedge.io/docs/architecture/beehive/#receive-by-a-module
F068,138,kubeedge/kubeedge,"""If timeout is reached, return timeout error.""",Reliability,https://kubeedge.io/docs/architecture/beehive/#sendsync-to-a-group
F069,138,kubeedge/kubeedge,"""If channel exists, message(response) is sent on that channel. Or else error is logged.""",Reliability,https://kubeedge.io/docs/architecture/beehive/#sendresp-to-a-sync-message
F070,138,kubeedge/kubeedge,"""It supports both web-socket based connection as well as a QUIC protocol access at the same time.""",Compatibility,https://kubeedge.io/docs/architecture/cloud/cloudhub
F071,138,kubeedge/kubeedge,"""The connection to the edge(through EdgeHub module) is done through the HTTP over websocket connection. For internal communication it directly communicates with the Controllers.""",Performance Efficiency,https://kubeedge.io/docs/architecture/cloud/cloudhub
F072,138,kubeedge/kubeedge,"""TLS certificates are loaded through the path provided in the context object.""",Security,https://kubeedge.io/docs/architecture/cloud/cloudhub
F073,138,kubeedge/kubeedge,"""HTTP server is started with TLS configurations.""",Security,https://kubeedge.io/docs/architecture/cloud/cloudhub
F074,138,kubeedge/kubeedge,"""A default message with timestamp, clientID and event type is sent to controller every time a request is made to websocket connection.""",Reliability,https://kubeedge.io/docs/architecture/cloud/cloudhub
F075,138,kubeedge/kubeedge,"""The downstream controller watches for device updates against the K8S API server."" ",Reliability,https://kubeedge.io/docs/architecture/cloud/device_controller/#downstream-controller
F076,138,kubeedge/kubeedge,"""The device controller is the cloud component of KubeEdge which is responsible for device management."" ",Maintainability,https://kubeedge.io/docs/architecture/cloud/device_controller/#device-controller-overview
F077,138,kubeedge/kubeedge,"""Device management in KubeEdge is implemented by making use of Kubernetes Custom Resource Definitions (CRDs) to describe device metadata/status and a device controller to synchronize these devices updates between edge and cloud."" ",Compatibility,https://kubeedge.io/docs/architecture/cloud/device_controller/#device-controller-overview
F078,138,kubeedge/kubeedge,"""The device controller starts two separate goroutines called upstream controller and downstream controller."" ",Performance Efficiency,https://kubeedge.io/docs/architecture/cloud/device_controller/#device-controller-overview
F079,138,kubeedge/kubeedge,"""The upstream controller watches for updates from the edge node and applies the updates against the API server in the cloud."" ",Reliability,https://kubeedge.io/docs/architecture/cloud/device_controller/#upstream-controller
F080,138,kubeedge/kubeedge,"""EdgeController is the bridge between Kubernetes Api-Server and edgecore""",Compatibility,https://kubeedge.io/docs/architecture/cloud/edge_controller
F081,138,kubeedge/kubeedge,"""Manager defines the interface of a manager, ConfigManager, Podmanager, secretmanager implements it""",Maintainability,https://kubeedge.io/docs/architecture/cloud/edge_controller#controller-manager
F082,138,kubeedge/kubeedge,"""Creates an eventManager(configMaps, pod, secrets) which will start a CommonResourceEventHandler, NewListWatch and a newShared Informer for each event to sync(add/update/delete)event(pod, configmap, secret) to edgecore via cloudHub""",Performance Efficiency,https://kubeedge.io/docs/architecture/cloud/edge_controller#controller-manager
F083,138,kubeedge/kubeedge,"""Downstream controller: Watches K8S Api-server and sends updates to edgecore via cloudHub""",Reliability,https://kubeedge.io/docs/architecture/cloud/edge_controller#downstream-controller
F084,138,kubeedge/kubeedge,"""UpstreamController receives messages from edgecore and syncs the updates to K8S-Api-server""",Reliability,https://kubeedge.io/docs/architecture/cloud/edge_controller#upstream-controller
F085,138,kubeedge/kubeedge,"""The main responsibility of communication module is to ensure the communication functionality between device twin and the other components.""","Compatibility, Flexibility, Maintainability",https://kubeedge.io/docs/architecture/edge/devicetwin/#communication-module
F086,138,kubeedge/kubeedge,"""The main responsibility of the device module is to perform the device related operations like dealing with device state updates and device attribute updates.""",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/devicetwin/#device-module
F087,138,kubeedge/kubeedge,"""The device twin controller periodically (every 60 s) sends ping messages to submodules. Each of the submodules updates the timestamp in a map for itself once it receives a ping. The controller checks if the timestamp for a module is more than 2 minutes old and restarts the submodule if true.""","Performance Efficiency, Maintainability, Flexibility",https://kubeedge.io/docs/architecture/edge/devicetwin/#health-check
F088,138,kubeedge/kubeedge,"""The main responsibility of the membership module is to provide membership to the new devices added through the cloud to the edge node. This module binds the newly added devices to the edge node and creates a membership between the edge node and the edge devices.""","Security, Reliability",https://kubeedge.io/docs/architecture/edge/devicetwin/#membership-module
F089,138,kubeedge/kubeedge,"""DeviceTwin module is responsible for storing device status, dealing with device attributes, handling device twin operations, creating a membership between the edge device and edge node, syncing device status to the cloud and syncing the device twin information between edge and cloud.""","Functional Suitability, Reliability, Performance Efficiency",https://kubeedge.io/docs/architecture/edge/devicetwin/#overview
F090,138,kubeedge/kubeedge,"""Registers the four device twin modules and starts them as separate go routines.""","Reliability, Interaction Capability",https://kubeedge.io/docs/architecture/edge/devicetwin/#register-and-start-sub-modules
F091,138,kubeedge/kubeedge,"""It checks if the device in the device twin context (the list of devices are stored inside the device twin context), if not it adds a mutex to the context.""","Functional Suitability, Reliability, Performance Efficiency",https://kubeedge.io/docs/architecture/edge/devicetwin/#sync-metadata-tofrom-db--sqlite-
F092,138,kubeedge/kubeedge,"""The main responsibility of the twin module is to deal with all the device twin-related operations. It can perform operations like device twin update, device twin get and device twin sync-to-cloud.""","Compatibility, Flexibility, Maintainability",https://kubeedge.io/docs/architecture/edge/devicetwin/#twin-module
F093,138,kubeedge/kubeedge,"""EdgeD is an edge node module which manages pod lifecycle. It helps users to deploy containerized workloads or applications at the edge node."" ",Maintainability,https://kubeedge.io/docs/architecture/edge/edged/#overview
F094,138,kubeedge/kubeedge,"""Several OCI-compliant runtimes are supported through the Container Runtime Interface (CRI)."" ",Flexibility,https://kubeedge.io/docs/architecture/edge/edged/#overview
F095,138,kubeedge/kubeedge,"""It also tracks the health of the pods using pod status manager and pleg."" ",Reliability,https://kubeedge.io/docs/architecture/edge/edged/#pod-management
F096,138,kubeedge/kubeedge,"""Probe management creates two probes for readiness and liveness respectively for pods to monitor the containers."" ",Reliability,https://kubeedge.io/docs/architecture/edge/edged/#probe-management
F097,138,kubeedge/kubeedge,"""Edged uses the MetaClient module to fetch secrets from MetaManager."" ",Security,https://kubeedge.io/docs/architecture/edge/edged/#secret-management
F098,138,kubeedge/kubeedge,"""A keep-alive message or heartbeat is sent to cloudHub after every heartbeatPeriod.""",Reliability,https://kubeedge.io/docs/architecture/edge/edgehub/#keep-alive
F099,138,kubeedge/kubeedge,"""Edge hub is responsible for interacting with CloudHub component present in the cloud. It can connect to the CloudHub using either a web-socket connection or using QUIC protocol.""",Compatibility,https://kubeedge.io/docs/architecture/edge/edgehub/#overview
F100,138,kubeedge/kubeedge,"""It supports functions like sync cloud side resources update, report edged side host and device status changes.""",Functional Suitability,https://kubeedge.io/docs/architecture/edge/edgehub/#overview
F101,138,kubeedge/kubeedge,"""It sends a beehive message to all groups (namely metaGroup, twinGroup and busGroup), informing them whether cloud is connected or disconnected.""",Reliability,https://kubeedge.io/docs/architecture/edge/edgehub/#publish-client-info
F102,138,kubeedge/kubeedge,"""The main responsibility of route to cloud is to receive from the other modules (through beehive framework), all the messages that are to be sent to the cloud, and send them to cloudHub through the websocket connection.""",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/edgehub/#route-to-cloud
F103,138,kubeedge/kubeedge,"""Eventbus acts as an interface for sending/receiving messages on mqtt topics."" ",Functional Suitability,https://kubeedge.io/docs/architecture/edge/eventbus/#overview
F104,138,kubeedge/kubeedge,"""The flow is almost the same in internal mode except the eventbus is as message broker itself."" ",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/eventbus#2-eventbus-sends-response-messages-to-external-client
F105,138,kubeedge/kubeedge,"""It supports 3 kinds of mode: internalMqttMode; externalMqttMode; bothMqttMode."" ",Compatibility,https://kubeedge.io/docs/architecture/edge/eventbus#overview
F106,138,kubeedge/kubeedge,"""MetaSync operation messages are periodically sent by metamanager to sync the status of the pods running on the edge node.""",Reliability,https://kubeedge.io/docs/architecture/edge/metamanager/?utm_source=chatgpt.com#metasync-operation
F107,138,kubeedge/kubeedge,"""The sync interval is configurable in conf/edgecore.yaml (defaults to 60 seconds).""",Maintainability,https://kubeedge.io/docs/architecture/edge/metamanager/?utm_source=chatgpt.com#metasync-operation
F108,138,kubeedge/kubeedge,"""MetaManager is the message processor between edged and edgehub. It's also responsible for storing/retrieving metadata to/from a lightweight database(SQLite).""",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/metamanager/?utm_source=chatgpt.com#overview
F109,138,kubeedge/kubeedge,"""ServiceBus is an HTTP client to interact with HTTP servers (REST), offering HTTP client capabilities to components of the cloud to reach HTTP servers running at the edge.""",Compatibility,https://kubeedge.io/docs/architecture/edge/servicebus#overview
F110,138,kubeedge/kubeedge,"""Cloud sends a beehive message to Edge via CloudHub.""",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/servicebus#working
F111,138,kubeedge/kubeedge,"""EdgeHub receives the messages and sends them to ServiceBus.""",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/servicebus#working
F112,138,kubeedge/kubeedge,"""ServiceBus just makes the HTTP call and sends the response to the cloud via EdgeHub.""",Performance Efficiency,https://kubeedge.io/docs/architecture/edge/servicebus#working
F113,141,lf-edge/edge-home-orchestration-go,"""Interoperable, flexible, and scalable edge computing services platform""",Compatibility,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture
F114,141,lf-edge/edge-home-orchestration-go,"""Provides an API for accessing the data storage"" (I/O Agent)",Maintainability,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Data-Storage-Module
F115,141,lf-edge/edge-home-orchestration-go,"""Provides a method for getting specific data from the data storage of the Home Edge device by rule-based approach"" (Command)",Safety,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Data-Storage-Module
F116,141,lf-edge/edge-home-orchestration-go,"""Finds the Home Edge devices in a user's home network"" (Edge Discovery)",Functional Suitability,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Edge-Orchestration-Module
F117,141,lf-edge/edge-home-orchestration-go,"""Manages lifecycle and replicas of services"" (Service Management)",Functional Suitability,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Edge-Orchestration-Module
F118,141,lf-edge/edge-home-orchestration-go,"""Re-deploys services to the other Home Edge device for load balancing"" (Service Offloading)",Performance Efficiency,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Edge-Orchestration-Module
F119,141,lf-edge/edge-home-orchestration-go,"""Checks and notifies the status of the Home Edge devices"" (Monitoring)",Security,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Edge-Orchestration-Module
F120,141,lf-edge/edge-home-orchestration-go,"""Provides unified APIs for the control of the connected home devices"" (Controller Adapter)",Compatibility,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Home-Device-Control-Module
F121,141,lf-edge/edge-home-orchestration-go,"""Schedules and allocates distributed job"" (Distributed Job Scheduler)",Performance Efficiency,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Machine-Learning-Module
F122,141,lf-edge/edge-home-orchestration-go,"""Divides model for distributed neural network processing"" (Model Partition Converter)",Flexibility,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Machine-Learning-Module
F123,141,lf-edge/edge-home-orchestration-go,"""Provides security features...such as secure on-boarding, Certificate, AAA, encryption/decryption""",Security,https://lf-edge.atlassian.net/wiki/spaces/HOME/pages/14587069/Home+Edge+Platform+Architecture#Security-Module
F124,142,lf-edge/ekuiper,"""Defines the continuous streaming data source as the input, the computing logic and the result actions as the output""",Functional Suitability,https://ekuiper.org/docs/en/latest/concepts/rules.html#rules
F125,142,lf-edge/ekuiper,"""Benefit from Go concurrency model, the runtime flow of a rule can communicate asynchronously and non-blocking""",Performance Efficiency,https://ekuiper.org/docs/en/latest/concepts/ekuiper.html#architecture-design
F126,142,lf-edge/ekuiper,"""Each rule can specify the operator buffer to limit the processing rate""",Performance Efficiency,https://ekuiper.org/docs/en/latest/concepts/rules.html#rules-relationship
F127,142,lf-edge/ekuiper,"""Sinks are used to write data to an external system""",Compatibility,https://ekuiper.org/docs/en/latest/concepts/sinks.html#sinks
F128,142,lf-edge/ekuiper,"""Users can define the format to decode by setting format property (json, binary, protobuf)""",Compatibility,https://ekuiper.org/docs/en/latest/concepts/sources/overview.html#decode
F129,142,lf-edge/ekuiper,"""Each rule will have its own, standalone source instance from other rules""",Security,https://ekuiper.org/docs/en/latest/concepts/sources/overview.html#define-and-run
F130,142,lf-edge/ekuiper,"""Users can also use mqtt or other sink/source pair to connect rules""",Maintainability,https://ekuiper.org/docs/en/latest/concepts/rules.html#rule-pipeline
F131,142,lf-edge/ekuiper,"""Users can develop a sink extension for detailed control""",Maintainability,https://ekuiper.org/docs/en/latest/concepts/sinks.html#result-encoding
F132,142,lf-edge/ekuiper,"""The source can be defined as shared to boost performance""",Flexibility,https://ekuiper.org/docs/en/latest/concepts/sources/overview.html#define-and-run
F133,142,lf-edge/ekuiper,"""Multiple rules can form a processing pipeline""",Flexibility,https://ekuiper.org/docs/en/latest/concepts/rules.html#rule-pipeline
F134,143,lf-edge/eve,"""Access to hardware root of trust (e.g. TPM) when deployed on bare metal, supporting functions such as crypto-based ID (no device usernames and passwords), measured boot, remote attestation, signed updates, encryption, etc.""",Security,https://lfedge.org/projects/eve/
F135,143,lf-edge/eve,"""Ability to block unused I/O ports to prevent physical tampering""",Security,https://lfedge.org/projects/eve/
F136,143,lf-edge/eve,"""High efficiency and usage of device resources including remote control of CPU, memory, networking and edge device I/O ports""",Performance Efficiency,https://lfedge.org/projects/eve/
F137,143,lf-edge/eve,"""Hosting of any combination of apps in virtual machines, containers and Kubernetes clusters""",Performance Efficiency,https://lfedge.org/projects/eve/
F138,143,lf-edge/eve,"""Remote updates of entire software stack with rollback capability to prevent bricking""",Maintainability,https://lfedge.org/projects/eve/
F139,143,lf-edge/eve,"""Automated patching for security updates""",Maintainability,https://lfedge.org/projects/eve/
F140,143,lf-edge/eve,"""EVE-OS can be deployed on any bare metal hardware (e.g., x86, Arm, GPU, RISC-V) or within a VM to provide consistent system and orchestration services""",Compatibility,https://lfedge.org/projects/eve/
F141,143,lf-edge/eve,"""EVE-OS enables scalable, centralized management for large volumes of highly-distributed edge compute nodes""",Interaction Capability,https://lfedge.org/projects/eve/
F142,148,loxilb-io/loxilb,"""The rationale of external mode is to provide users a similar look and feel whether running loxilb in an on-prem or public cloud environment.""",Compatibility,https://docs.loxilb.io/latest/kube-loxilb/#what-is-kube-loxilb
F143,148,loxilb-io/loxilb,"""Public-cloud environments usually run load-balancers/firewalls externally in order to provide a secure/dmz perimeter layer outside actual workloads.""",Security,https://docs.loxilb.io/latest/kube-loxilb/#what-is-kube-loxilb
F144,148,loxilb-io/loxilb,"""kube-loxilb runs as a deloyment set in kube-system namespace. It is a control-plane component that always runs inside k8s cluster and watches k8s system for changes to nodes/end-points/reachability/LB services etc.""",Performance Efficiency,https://docs.loxilb.io/latest/kube-loxilb/#what-is-kube-loxilb
F145,148,loxilb-io/loxilb,"""loxilb docker is a self-contained entity and easily managed with well-known tools like docker, containerd, podman etc.""",Maintainability,https://docs.loxilb.io/latest/kube-loxilb/#this-usually-leads-to-another-query-in-external-mode-who-will-be-responsible-for-managing-this-entity
F146,148,loxilb-io/loxilb,"""Better performance is desired due to active-active clustering but network devices/hosts must be capable of supporting ECMP.""",Performance Efficiency,https://docs.loxilb.io/latest/ha-deploy/#setup_2
F147,148,loxilb-io/loxilb,"""Need fast failover detection and service continuity.""",Performance Efficiency,https://docs.loxilb.io/latest/ha-deploy/#ideal-for-use-when_4
F148,148,loxilb-io/loxilb,"""Tracks and directs the external traffic destined to svc to the endpoints. Monitors endpoint's health and chooses active endpoints, if configured.""",Reliability,https://docs.loxilb.io/latest/ha-deploy/#roles-and-responsiblities-for-loxilb_4
F149,148,loxilb-io/loxilb,"""Syncs the long-lived connections to all other configured loxilb peers.""",Reliability,https://docs.loxilb.io/latest/ha-deploy/#roles-and-responsiblities-for-loxilb_3
F150,148,loxilb-io/loxilb,"""Automates provisioning of BGP-peering between loxilb pods.""",Maintainability,https://docs.loxilb.io/latest/ha-deploy/#roles-and-responsiblities-for-kube-loxilb_1
F151,148,loxilb-io/loxilb,"""Sets up loxilb in one-arm svc mode towards end-points.""",Maintainability,https://docs.loxilb.io/latest/ha-deploy/#roles-and-responsiblities-for-kube-loxilb_1
F152,148,loxilb-io/loxilb,"""Clients and Cluster are in different subnets. Clients and svc VIP need to be in different subnet (cluster end-points may also be in different networks).""",Compatibility,https://docs.loxilb.io/latest/ha-deploy/#setup_2
F153,148,loxilb-io/loxilb,"""Ideal for cloud deployments.""",Flexibility,https://docs.loxilb.io/latest/ha-deploy/#setup_1
F154,148,loxilb-io/loxilb,"""--blacklist=cni[0-9a-z]|veth.|flannel."" [...] ""regex must be used with calico CNI.""",Security,https://docs.loxilb.io/latest/ha-deploy/#roles-and-responsiblities-for-loxilb_2
F155,148,loxilb-io/loxilb,"""In case of failure, BFD will detect the failure. BACKUP loxilb will update its state to new master.""",Reliability,https://docs.loxilb.io/latest/ha-deploy/#failover_4
F156,154,mindspore-ai/mindspore,"""Efficient execution is reflected in computing, data preprocessing, and distributed training.""",Performance Efficiency,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F157,154,mindspore-ai/mindspore,"""Data processing (MindSpore Data): provides high-performance data loading, data preprocessing functions.""",Performance Efficiency,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F158,154,mindspore-ai/mindspore,"""Compiler Optimization (MindCompiler): [...] performs global performance optimizations, including hardware-independent optimizations such as auto-differentiation and algebraic reduction, and hardware-relevant optimizations such as graph-operation fusion and operation generation.""",Performance Efficiency,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F159,154,mindspore-ai/mindspore,"""Unified deployment for all scenarios means that the framework supports cloud, edge, and device scenarios.""",Flexibility,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F160,154,mindspore-ai/mindspore,"""MindIR provides a unified IR format for the device and cloud, which defines logical network structures and operator attributes through a unified IR, and decouples model files in MindIR format from hardware platforms to implement one-time training and multiple-time deployment.""",Flexibility,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F161,154,mindspore-ai/mindspore,"""MindSpore Armour module to provide an AI security mechanism for MindSpore.""",Security,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F162,154,mindspore-ai/mindspore,"""The simplest scenario to ensure AI security is from the perspective of attack and defense. For example, attackers inject malicious data in the training phase to affect the inference capability of AI models.""",Security,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F163,154,mindspore-ai/mindspore,"""As an all-scenario AI framework, MindSpore supports different series of hardware in the device (mobile phone and IoT device), edge (base station and routing device), and cloud (server) scenarios, including Ascend series products and NVIDIA series products, Qualcomm Snapdragon in the ARM series, and Huawei Kirin chips.""",Compatibility,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F164,154,mindspore-ai/mindspore,"""MindSpore unifies the coding methods of single device and distributed training. Developers do not need to write complex distributed strategies. They can implement distributed training by adding a small amount of code to the single device code.""",Compatibility,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F165,154,mindspore-ai/mindspore,"""Easy development features user-friendly APIs and low debugging difficulty.""",Interaction Capability,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F166,154,mindspore-ai/mindspore,"""MindSpore provides a Python programming paradigm. Users can build complex neural network models using Python's native control logic, making AI programming easy.""",Interaction Capability,https://www.mindspore.cn/tutorials/en/master/beginner/introduction.html
F167,163,MontiCore/montithings,"""MontiThings automatically makes modification proposals according to which either new hardware is purchased or rules are weakened...""",Performance Efficiency,https://www.se-rwth.de/research/MontiThings/
F168,163,MontiCore/montithings,"""...components can also serialize their state directly (usually after a constant number of processed messages) and store it in a central system.""",Performance Efficiency,https://www.se-rwth.de/research/MontiThings/
F169,163,MontiCore/montithings,"""Even if developers take great care in modeling their application, unfortunately not all errors are always predictable.""",Reliability,https://www.se-rwth.de/research/MontiThings/
F170,163,MontiCore/montithings,"""MontiThings provides tools and methods to analyze such errors as well as to fix them automatically (within certain limits).""",Reliability,https://www.se-rwth.de/research/MontiThings/
F171,163,MontiCore/montithings,"""At runtime, log messages of components can be traced within the architecture similar to a 'stack trace' to find the root cause of their occurrence.""",Reliability,https://www.se-rwth.de/research/MontiThings/
F172,163,MontiCore/montithings,"""If a component fails because the IoT device running it is no longer functional, one possible automatic troubleshooting strategy is for MontiThings to transfer the component to another suitable device.""",Reliability,https://www.se-rwth.de/research/MontiThings/
F173,163,MontiCore/montithings,"""Architectures can be observed at runtime and then modified by model-to-model transformations to make their behavior reproducible for developers retrospectively.""",Maintainability,https://www.se-rwth.de/research/MontiThings/
F174,163,MontiCore/montithings,"""To handle non-deterministic behavior and to reduce the complexity of this procedure to O(1)...""",Maintainability,https://www.se-rwth.de/research/MontiThings/
F175,163,MontiCore/montithings,"""Device owners can express their local requirements in the form of rules. For example, you can prohibit recording software from running in the bedroom or require that smoke detector components are executed in each room.""",Security,https://www.se-rwth.de/research/MontiThings/
F176,163,MontiCore/montithings,"""MontiThings includes an app store concept that separates hardware and software development.""",Interaction Capability,https://www.se-rwth.de/research/MontiThings/
F177,163,MontiCore/montithings,"""The hardware developers on the other hand develop the drivers necessary to connect software components to their hardware.""",Interaction Capability,https://www.se-rwth.de/research/MontiThings/
F178,258,nesl/auritus,"""First, pair the earable you want to use with your smartphone via Bluetooth. Next, open the app, type the device name as it appeared when pairing, and press CONNECT TO DEVICE.""",Interaction Capability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F179,258,nesl/auritus,"""To stop logging data, click DISCONNECT FROM DEVICE.""",Interaction Capability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F180,258,nesl/auritus,"""The app starts to log earable data. The data is stored in .csv format in Internal Storage/ESENSE_DATA/RAW_X.txt.""",Reliability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F181,258,nesl/auritus,"""We setup six Optitrack Prime 13 cameras in the MoCap setup in conjunction with Motive:Tracker software to collect head-pose data.""",Reliability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F182,258,nesl/auritus,"""To find the azimuth angle, elevation angle and distance of the targets from the spot where participants sit, we used a laser rangefinder and digital compass in smartphone.""","Reliability, Flexibility",https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F183,258,nesl/auritus,"""We use eSense earables from Nokia Bell Labs.""",Functional Suitability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F184,258,nesl/auritus,"""We use sticky notes to place head-pose targets around the room.""",Functional Suitability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F185,258,nesl/auritus,"""We use laser pointers to guide the head-movements of participants.""",Functional Suitability,https://github.com/nesl/auritus/tree/main/Data%20Collection%20Module
F186,258,nesl/auritus," ""We recommend using the MATLAB IEKF script for prototyping IEKF, while using Python scripts to prototype Madgwick, Mahony and complementary filter.""",Functional Suitability,https://github.com/nesl/auritus/blob/main/Filter%20Development%20and%20Deployment/README.md#filter-development-and-deployment-module
F187,258,nesl/auritus,"""The C files have been tested in Arduino for Mbed-enabled and AVR-RISC microcontrollers.","Performance Efficiency, Maintainability, Reliability",https://github.com/nesl/auritus/tree/main/Filter%20Development%20and%20Deployment#filter-development-and-deployment-module
F188,258,nesl/auritus,"""The complementary filter is written to operate with MPU-6050 IMU breakout.""",Compatibility,https://github.com/nesl/auritus/tree/main/Filter%20Development%20and%20Deployment#filter-development-and-deployment-module
F189,258,nesl/auritus,"""It will automatically create a folder with appropriate subject ID and slice the activity data automatically.""",Functional Suitability,https://github.com/nesl/auritus/blob/main/Data%20Labeling%20Module/README.md#how-to-do-labeling-for-activity-detection
F190,258,nesl/auritus,"""You should see the cursor_info variable in the workspace now, whose size should be 1X18 (for 9 activities).""",Functional Suitability,https://github.com/nesl/auritus/blob/main/Data%20Labeling%20Module/README.md#how-to-do-labeling-for-activity-detection
F191,258,nesl/auritus,"""The training folder contains guide (and necessary code) on how to train conventional activity classification models in MATLAB.""",Functional Suitability,https://github.com/nesl/auritus/tree/main/Model%20Development%20and%20Deployment#model-development-and-deployment
F192,258,nesl/auritus,"""The Jupyter notebook for each model primarily imports the dataset, extracts features (optional), performs hyperparameter tuning or NAS via Bayesian optimization, trains the best model and provides deployable C++ / .tflite files for model deployment.""","Functional Suitability, Interaction Capability, Compatibility",https://github.com/nesl/auritus/tree/main/Model%20Development%20and%20Deployment#model-development-and-deployment
F193,258,nesl/auritus,"""We also provide the best-performing pre-trained conventional models.""","Performance Efficiency, Reliability",https://github.com/nesl/auritus/tree/main/Model%20Development%20and%20Deployment#model-development-and-deployment
F194,258,nesl/auritus,"""Before running the code in TinyML Models, please run data_prep.py to prepare the dataset ready for use by the dataset importer used in the TinyML model scripts.""",Performance Efficiency,https://github.com/nesl/auritus/tree/main/Model%20Development%20and%20Deployment#model-development-and-deployment
F195,258,nesl/auritus,"""The TinyML models are written to be trained on GPU.""","Performance Efficiency, Compatibility, Reliability",https://github.com/nesl/auritus/tree/main/Model%20Development%20and%20Deployment#model-development-and-deployment
F196,258,nesl/auritus,"""The best-performing pre-trained conventional models in each folder within the Deployment folder to allow users run the deployment scripts.""",Compatibility,https://github.com/nesl/auritus/tree/main/Model%20Development%20and%20Deployment#model-development-and-deployment
F197,194,pytorch/executorch,"""In order to target on-device AI with diverse hardware, critical power requirements, and realtime processing needs, a single monolithic solution is not practical. Instead, a modular, layered, and extendable architecture is desired.""",Flexibility,https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#high-level-architecture-and-components-of-executorch
F198,194,pytorch/executorch,"""Program preparation is often simply called AOT (ahead-of-time) because export, transformations and compilations to the program are performed before it is eventually run with the ExecuTorch runtime, written in C++. To have a lightweight runtime and small overhead in execution, we push work as much as possible to AOT.""",Performance Efficiency,https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#program-preparation
F199,194,pytorch/executorch,"""This architecture greatly improves portability, allowing engineers to use a performant lightweight, cross-platform runtime that easily integrates into different devices and platforms.""",Flexibility,https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#high-level-architecture-and-components-of-executorch
F200,194,pytorch/executorch,"""Optionally, quantization, either QAT (quantization-aware training) or PTQ (post training quantization) can be applied to the whole ATen graph before converting to Core ATen. Quantization helps with reducing the model size, which is important for edge devices.""",Safety,https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#export
F201,194,pytorch/executorch,"""User-defined passes. Target-specific transforms can also be performed by the user. Good examples of this are kernel fusion, async behavior, memory layout conversion, and others.""",Maintainability,https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#edge-compilation
F202,194,pytorch/executorch,"""On most Edge environments, dynamic memory allocation/freeing has significant performance and power overhead. It can be avoided using AOT memory planning, and a static execution graph.""",Performance Efficiency,https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#compile-to-executorch-program
F203,194,pytorch/executorch,"""ExecuTorch has the selective build APIs, to build the runtime that links to only kernels used by the program, which can provide significant binary size savings in the resulting application.""","Performance Efficiency, Flexibility",https://github.com/pytorch/executorch/blob/main/docs/source/getting-started-architecture.md#runtime-preparation
F204,257,ztachip/ztachip,"""But with ztachip, data are loaded from external memory into internal memory in a streaming fashion with prefetching and no round-trip delay. This results in huge gain in memory bandwidth usage efficiencies.""",Performance Efficiency,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F205,257,ztachip/ztachip,"""Each vector element additions are carried out by separate threads and pcores, enable huge processing parallelism.""",Performance Efficiency,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F206,257,ztachip/ztachip,"""The goal for DSL is to provide a programming language that is: Easy to use and learn.""",Interaction Capability,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F207,257,ztachip/ztachip,"""Hide the complexity of hardware implementation from software users.""",Interaction Capability,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F208,257,ztachip/ztachip,"""Tensor-core programs are C-program but with some special extensions.""",Maintainability,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F209,257,ztachip/ztachip,"""There is a compiler provided with ztachip that converts these special extension to tensor instructions before the program can then be compiled with standard RISCV C compiler.""",Maintainability,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F210,257,ztachip/ztachip,"""Due to limited memory, all tensor operator objects are singleton and overlapped in memory. Users must partition these objects in such a way that they are not in use at the same time.""",Reliability,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F211,257,ztachip/ztachip,"""With vector addition example above, traditional architecture requires each vector elements (or a small number of them for the case of vector extension) to be loaded first to memory one at a time and then followed by addition.""",Performance Efficiency,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F212,257,ztachip/ztachip,"""This would create a lot of memory round trip delay and stall cycles when data is not readily available in L1 cache.""",Performance Efficiency,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F213,257,ztachip/ztachip,"""Tensor-core programs are codes that run on RISCV.""",Compatibility,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F214,257,ztachip/ztachip,"""p-core program implements the tensor operators that are referenced by tensor-core programs.""",Compatibility,https://github.com/ztachip/ztachip/blob/master/Documentation/SoftwareDesign.md
F215,3,absmach/supermq,"""Magistrala uses NATS as its default messaging backbone, due to its lightweight and performant nature. You can treat its subjects as physical representation of Magistrala channels, where subject name is constructed using channel unique identifier. Magistrala also provides the ability to change your default message broker to RabbitMQ, VerneMQ or Kafka.""",Compatibility,https://docs.magistrala.abstractmachines.fr/architecture/#messaging
F216,3,absmach/supermq,"""Magistrala platform can be run on the edge as well. Deploying Magistrala on a gateway makes it able to collect, store and analyze data, organize and authenticate devices.""",Flexibility,https://docs.magistrala.abstractmachines.fr/architecture/#edge
F217,3,absmach/supermq,"""The platform is built upon SuperMQ which is built around 2 main entities: users and clients.""",Maintainability,https://docs.magistrala.abstractmachines.fr/architecture/#domain-model
F218,9,aklivity/zilla,"""Zilla is stateless, cloud-native, and supports various network and application protocols, including HTTP, Kafka, SSE, MQTT, gRPC, and WebSocket (additional protocols are on the way).""",Flexibility,https://docs.aklivity.io/zilla/latest/concepts/what-is-zilla.html#what-is-zilla
F219,9,aklivity/zilla,"""Zilla has no external dependencies, is stateless, and is highly memory efficient. When deployed as an edge proxy, it scales horizontally to support millions of concurrently connected clients.""",Performance Efficiency,https://docs.aklivity.io/zilla/latest/concepts/what-is-zilla.html#self-contained-stateless-architecture
F220,9,aklivity/zilla,"""Zilla supports payload schema specifications for message validation and translation.""",Reliability,https://docs.aklivity.io/zilla/latest/concepts/what-is-zilla.html#protobuf-avro-and-json-schema-payloads
F221,9,aklivity/zilla,"""Zilla can terminate TLS and supports JWT-based authorization for REST, SSE, and MQTT endpoints/services.""",Security,https://docs.aklivity.io/zilla/latest/concepts/what-is-zilla.html#security
F222,9,aklivity/zilla,"""Zilla can expose a Prometheus metrics endpoint and logs events to stdout. Additionally, Zilla supports OpenTelemetry for both metrics and logging.""",Maintainability,https://docs.aklivity.io/zilla/latest/concepts/what-is-zilla.html#observability
F223,13,AmbiqAI/heartkit,"""HeartKit provides several built-in heart-monitoring tasks. Each task is designed to address a unique aspect such as ECG denoising, segmentation, and rhythm/beat classification. The tasks are designed to be modular and can be used independently or in combination to address specific use cases.""",Maintainability,https://ambiqai.github.io/heartkit/tasks/?h=intro#introduction
F224,13,AmbiqAI/heartkit,"""In addition to the built-in tasks, custom tasks can be created by extending the HKTask base class and registering it with the task factory.""",Maintainability,https://ambiqai.github.io/heartkit/tasks/?h=intro#introduction
F225,13,AmbiqAI/heartkit,"""The task factory, TaskFactory, provides a convenient way to access the built-in tasks. The factory is a thread-safe singleton class that provides a single point of access to the tasks via the tasks' slug names.""",Reliability,https://ambiqai.github.io/heartkit/tasks/?h=intro#task-factory
F226,13,AmbiqAI/heartkit,"""Bring-Your-Own-Task (BYOT) is a feature that allows users to create custom tasks by extending the HKTask base class and registering it with the TaskFactory. This feature is useful for addressing specific use cases that are not covered by the built-in tasks.""","Functional Suitability, Maintainability",https://ambiqai.github.io/heartkit/tasks/?h=intro#bring-your-own-task-byot
F227,13,AmbiqAI/heartkit,"""Signal denoise is the process of removing noise from a physiological signal such as ECG. This task is useful for improving the quality of the signal and for further downstream tasks such as segmentation in which noise can interfere with the delineation of individual waves.""",Functional Suitability,https://ambiqai.github.io/heartkit/tasks/?h=intro#signal-denoise
F228,13,AmbiqAI/heartkit,"""Rhythm classification is the process of identifying abnormal heart rhythms, also known as arrhythmias, such as atrial fibrillation (AFIB) and atrial flutter (AFL) from ECG signals.""",Functional Suitability,https://ambiqai.github.io/heartkit/tasks/?h=intro#rhythm-classification
F229,22,aws/aws-iot-fleetwise-edge,"""AWS IoT FleetWise is an AWS service that enables automakers and fleet operators to collect, store, organize, and monitor data from vehicles.""",Functional Suitability,https://github.com/aws/aws-iot-fleetwise-edge?tab=readme-ov-file#aws-iot-fleetwise-architecture
F230,22,aws/aws-iot-fleetwise-edge,"""AWS IoT FleetWise can be used by OEM engineers and data scientists to build vehicle models that can be used to build custom data collection schemes.""",Maintainability,https://github.com/aws/aws-iot-fleetwise-edge?tab=readme-ov-file#aws-iot-fleetwise-architecture
F231,22,aws/aws-iot-fleetwise-edge,"""Customers can define the data collection schemes to trigger based on a schedule or on specific conditions such as, but not limited to: 1. Ambient temperature dropping to below 0 degree or 2. Vehicle crosses state lines or 3. Active diagnostic trouble codes.""","Functional Suitability, Interaction Capability",https://github.com/aws/aws-iot-fleetwise-edge?tab=readme-ov-file#aws-iot-fleetwise-architecture
F232,22,aws/aws-iot-fleetwise-edge,"""FWE receives two documents: 1. Decoder Manifest - this document describes how signals are collected from the vehicle, and will include details such as, but not limited to: Bus ID, network name, decoding information, etc.""",Compatibility,https://github.com/aws/aws-iot-fleetwise-edge?tab=readme-ov-file#aws-iot-fleetwise-architecture
F233,22,aws/aws-iot-fleetwise-edge,"""2. Data Collection Schemes - this document describes what signals to collect. It also describes the condition logic that defines the enablement of the trigger logic that allows these signals to be collected, for example, when Vehicle Speed > 100 km/Hr and Driver Seatbelt is Off and Ambient Temperature < 0 degree C.""",Reliability,https://github.com/aws/aws-iot-fleetwise-edge?tab=readme-ov-file#aws-iot-fleetwise-architecture
F234,23,axem-solutions/dem,"""The Development Environment Manager (DEM) provides an abstraction layer for the Development Platform, which encompasses a collection of available resources, such as registries, catalogs, container engines, and more.""",Maintainability,https://www.axemsolutions.io/dem_doc/latest/design/#architectural-overview
F235,23,axem-solutions/dem,"""DEM implements commands that can interact with the platform. These commands can be executed using the command line interface (CLI). Additionally, some commands utilize a Text-based User Interface (TUI) that can be presented on the user's terminal.""",Interaction Capability,https://www.axemsolutions.io/dem_doc/latest/design/#architectural-overview
F236,23,axem-solutions/dem,"""The CLI can communicate with the platform in two ways: 1. Over the Platform API, which can be achieved by instantiating the DevEnvLocalSetup class. 2. By registering a UserOutput class, which is used by the core modules to interact with the user.""",Compatibility,https://www.axemsolutions.io/dem_doc/latest/design/#architectural-overview
F237,23,axem-solutions/dem,"""The platform module depends on the rest of the resources. This concept allows for the creation of a unified interface for all internal resources.""",Maintainability,https://www.axemsolutions.io/dem_doc/latest/design/#core-components
F238,23,axem-solutions/dem,"""Docker is used to communicate directly with the Docker Engine. (The Docker CLI is not utilized.)""",Performance Efficiency,https://www.axemsolutions.io/dem_doc/latest/design/#docker
F239,23,axem-solutions/dem,"""A registry acts as a storage for tool images, allowing them to be stored without consuming space on a developer's computer. This storage facilitates easy sharing of images among collaborators, ensuring consistent tool usage across the project team.""",Flexibility,https://www.axemsolutions.io/dem_doc/latest/basics/#registry-and-repository
F240,24,Azure-Samples/azure-iot-edge-identity-translation-lite,"""This identity translation module is based on the IdentityTranslationLite design and implements the Identity Translation Pattern. This pattern contains both protocol translation and identity translation.""",Compatibility,https://github.com/Azure-Samples/azure-iot-edge-identity-translation-lite/blob/master/docs/identitytranslationmodule.md#introduction
F241,24,Azure-Samples/azure-iot-edge-identity-translation-lite,"""The Identity Translation module should be configured in the routing table of the IoT Edge device to receive messages from the protocol translation module and send messages to the IoTHub (upstream).""",Performance Efficiency,https://github.com/Azure-Samples/azure-iot-edge-identity-translation-lite/blob/master/docs/identitytranslationmodule.md#message-routing
F242,24,Azure-Samples/azure-iot-edge-identity-translation-lite,"""If this is the first messages received for this leaf device (the leafDeviceId cannot be found in the local device repository), a 'LeafEvent' of type 'create' is sent to the IoTHub indicating that the device should be created by the Azure Function in Azure.""",Reliability,https://github.com/Azure-Samples/azure-iot-edge-identity-translation-lite/blob/master/docs/identitytranslationmodule.md#message-processing
F243,24,Azure-Samples/azure-iot-edge-identity-translation-lite,"""The leaf devices are using a symmetric key to authenticate with IoTHub. The symmetric key that is used for this authentication is calculated from the id of the leaf device and the symmetric key of the identity module.""",Security,https://github.com/Azure-Samples/azure-iot-edge-identity-translation-lite/blob/master/docs/identitytranslationmodule.md#device-identity
F244,24,Azure-Samples/azure-iot-edge-identity-translation-lite,"""The solution also comprises a cloud section that takes care of provisioning the device on the IoT Hub and assigning it as a child of the IoT Edge device.""",Maintainability,https://github.com/Azure-Samples/azure-iot-edge-identity-translation-lite?tab=readme-ov-file#key-concepts
F245,24,Azure-Samples/azure-iot-edge-identity-translation-lite,"""The sample setup flow uses an unsecure MQTT broker connection (mosquitto) to interact with clients (represented by the Python script sim_clients.py) and a custom implemented protocol translation module (ptm-mqtt) to interact with the identity translation module.""",Flexibility,https://github.com/Azure-Samples/azure-iot-edge-identity-translation-lite?tab=readme-ov-file#sample-setup-flow
F246,25,Azure-Samples/edge-aio-in-a-box,"""The core solution runs on an Ubuntu-based virtual machine using K3s. Alternatively, you can deploy this solution to a dedicated hybrid edge device, allowing the machine learning model to operate closer to your equipment.""",Flexibility,https://github.com/Azure-Samples/edge-aio-in-a-box/tree/main?tab=readme-ov-file#architecture
F247,25,Azure-Samples/edge-aio-in-a-box,"""You will leverage Azure ML Model Creation/Deployment to a K3s/AIO Cluster Endpoint. This template provisions the essential Azure Machine Learning resources, the Azure ML Extension, and accompanying notebooks.""",Compatibility,https://github.com/Azure-Samples/edge-aio-in-a-box/tree/main?tab=readme-ov-file#quick-overview-of-the-resources-to-be-deployed-with-this-template
F248,25,Azure-Samples/edge-aio-in-a-box,"""Once you have your model, you can deploy it to your AIO K3s Cluster: Build your model into a Docker image and push it to your Kubernetes/AIO endpoint; Use the Azure ML Extension to serve as the bridge between Azure ML and your K3s/AIO cluster.""",Performance Efficiency,https://github.com/Azure-Samples/edge-aio-in-a-box/tree/main?tab=readme-ov-file#quick-overview-of-the-resources-to-be-deployed-with-this-template
F249,25,Azure-Samples/edge-aio-in-a-box,"""You will utilize Cerebral to run GenAI directly at the edge on the K3s/AIO Cluster. Cerebral will be deployed out of the box with this template.""",Reliability,https://github.com/Azure-Samples/edge-aio-in-a-box/tree/main?tab=readme-ov-file#quick-overview-of-the-resources-to-be-deployed-with-this-template
F250,25,Azure-Samples/edge-aio-in-a-box,"""A Streamlit application will also be deployed, demonstrating how you can operate within an application on the K3s/Azure IoT Operations (AIO) cluster while leveraging Azure OpenAI, LangChain, and a local small language model (SLM).""",Interaction Capability,https://github.com/Azure-Samples/edge-aio-in-a-box/tree/main?tab=readme-ov-file#quick-overview-of-the-resources-to-be-deployed-with-this-template
F251,29,Azure/azure-iotedge,"""Os mdulos do IoT Edge so unidades de execuo, implementados como contineres compatveis com o Docker, que executam a lgica de negcios na borda. Vrios mdulos podem ser configurados para se comunicar entre si, criando um pipeline de processamento de dados.""",Maintainability,https://learn.microsoft.com/pt-br/azure/iot-edge/about-iot-edge#iot-edge-modules
F252,29,Azure/azure-iotedge,"""O Azure IoT Edge permite implantar processamento de eventos complexos, aprendizado de mquina, reconhecimento de imagem e outros tipos de IA de alto valor sem grav-la internamente.""",Functional Suitability,https://learn.microsoft.com/pt-br/azure/iot-edge/about-iot-edge#artificial-intelligence-at-the-edge
F253,29,Azure/azure-iotedge,"""O Azure IoT Edge oferece suporte para Linux e Windows, portanto voc pode codificar para a plataforma de sua escolha. Ele d suporte para Java, .NET Core 3.1, Node.js, C e Python, para que os desenvolvedores possam codificar em uma linguagem que j conhecem e usar a lgica de negcios existente.""",Flexibility,https://learn.microsoft.com/pt-br/azure/iot-edge/about-iot-edge#bring-your-own-code
F254,29,Azure/azure-iotedge,"""O runtime do Azure IoT Edge permite lgica personalizada e de nuvem em dispositivos IoT Edge. O runtime se encontra no dispositivo IoT Edge e executa operaes de gerenciamento e comunicao.""",Compatibility,https://learn.microsoft.com/pt-br/azure/iot-edge/about-iot-edge#iot-edge-runtime
F255,29,Azure/azure-iotedge,"""O runtime do Azure IoT Edge  executado em um grande conjunto de dispositivos IoT, o que permite que seja usado de vrias maneiras. Ele d suporte a sistemas operacionais Windows e Linux e abstrai os detalhes de hardware.""","Interaction Capability, Flexibility",https://learn.microsoft.com/pt-br/azure/iot-edge/about-iot-edge#iot-edge-runtime
F256,29,Azure/azure-iotedge,"""O Azure IoT Edge se integra perfeitamente ao Azure IoT Central para fornecer um painel de controle centralizado para as necessidades da sua soluo.""",Maintainability,https://learn.microsoft.com/pt-br/azure/iot-edge/about-iot-edge#iot-edge-cloud-interface
F257,31,Azure/iotedge,"""The IoT Edge Runtime manages high-value services running on devices and enables communication between them. It allows workflows running on devices to be configured, deployed and monitored from the cloud - securely and at scale.""",Maintainability,https://github.com/Azure/iotedge/blob/main/doc/EdgeDesign.md#edge-runtime
F258,31,Azure/iotedge,"""Edge Agent - The edge agent is designed to communicate with IoT Hub in order to manage the state of the Edge device (install, launch and monitor modules).""",Compatibility,https://github.com/Azure/iotedge/blob/main/doc/EdgeDesign.md#edge-agent
F259,31,Azure/iotedge,"""User-defined modules allow companies or individuals to create custom or tailored solutions specific to their needs which can be managed by the Edge Runtime.""",Maintainability,https://github.com/Azure/iotedge/blob/main/doc/EdgeDesign.md#user-defined-modules
F260,31,Azure/iotedge,"""In environments where the upstream connection has limited throughput (e.g. cellular or satellite), often times certain critical data needs to take precedence over the mass of normal telemetry messages to ensure speedy delivery.""",Performance Efficiency,https://github.com/Azure/iotedge/blob/main/doc/Route_priority_and_TTL.md#context
F261,31,Azure/iotedge,"""IoT Edge uses the networking capabilities of the Moby runtime to connect to IoT Hub and provide connectivity between modules.""",Reliability,https://github.com/Azure/iotedge/blob/main/doc/networking.md#networking-on-iot-edge
F262,31,Azure/iotedge,"""Edge Agent and Edge Hub require outbound internet connectivity to IoT Hub to function properly. This means that a route from the azure-iot-edge subnet to the internet must exist and no firewall rules are set up to block traffic.""",Security,https://github.com/Azure/iotedge/blob/main/doc/networking.md#user-defined-network-linux-only
F263,32,Azure/iotedge-eflow,"""O Azure IoT Edge para Linux no Windows usa os seguintes componentes para permitir que as cargas de trabalho do Linux e do Windows sejam executadas lado a lado e comuniquem-se perfeitamente.""",Compatibility,https://learn.microsoft.com/pt-br/azure/iot-edge/iot-edge-for-linux-on-windows#components
F264,32,Azure/iotedge-eflow,"""A comunicao bidirecional entre o processo do Windows e a mquina virtual Linux significa que os processos do Windows podem fornecer interfaces do usurio ou proxies de hardware para cargas de trabalho executadas nos contineres do Linux.""",Interaction Capability,https://learn.microsoft.com/pt-br/azure/iot-edge/iot-edge-for-linux-on-windows#components
F265,32,Azure/iotedge-eflow,"""Todas as comunicaes entre o sistema operacional Windows do host e a mquina virtual EFLOW exigida pelos cmdlets do PowerShell so feitas usando um canal SSH. [...] O servio SSH da mquina virtual no permitir a autenticao por meio de nome de usurio e senha e est limitado  autenticao de certificado.""",Security,https://learn.microsoft.com/pt-br/azure/iot-edge/iot-edge-for-linux-on-windows-security#secure-host--virtual-machine-communication
F266,32,Azure/iotedge-eflow,"""A mquina virtual EFLOW  criada em uma plataforma de segurana abrangente de quatro pontos: 1. Atualizaes de manuteno 2. Sistema de arquivos raiz somente leitura 3. Bloqueio de firewall 4. DM-Verity.""",Reliability,https://learn.microsoft.com/pt-br/azure/iot-edge/iot-edge-for-linux-on-windows-security#virtual-machine-security
F267,32,Azure/iotedge-eflow,"""Para criar um canal de comunicao entre o sistema operacional host Windows e a mquina virtual EFLOW, usamos a pilha de rede do Hyper-V.""",Performance Efficiency,https://learn.microsoft.com/pt-br/azure/iot-edge/iot-edge-for-linux-on-windows-networking#networking
F268,32,Azure/iotedge-eflow,"""Diversos dispositivos virtuais de rede e cenrios exigem vrias NICs. A mquina virtual EFLOW d suporte  anexao de vrias NICs. Com vrias NICs, voc gerencia melhor o trfego de rede.""",Flexibility,https://learn.microsoft.com/pt-br/azure/iot-edge/iot-edge-for-linux-on-windows-networking#multiple-network-interface-cards-nics
F269,33,Azure/iotedge-lorawan-starterkit,"""LoRaWAN is a type of wireless wide-area networking that is designed to allow long-range communication at a low bit rate among low-power connected objects, such as sensors operated on a battery.""",Performance Efficiency,https://azure.github.io/iotedge-lorawan-starterkit/2.2.1/user-guide/architecture/?h=archi#background
F270,33,Azure/iotedge-lorawan-starterkit,"""Network topology is of star-of-stars type, with the leaf sensors sending data to gateways for forwarding telemetry to and receiving commands from backing Internet services.""",Reliability,https://azure.github.io/iotedge-lorawan-starterkit/2.2.1/user-guide/architecture/?h=archi#background
F271,33,Azure/iotedge-lorawan-starterkit,"""Nowadays, even for simple scenarios like having 10 devices connected to a single LoRaWan gateway (hardware with antenna), you need to connect your gateway to a Network Server and then work through connectors provided by the server vendor to integrate your LoRa gateways and devices with the back end.""",Compatibility,https://azure.github.io/iotedge-lorawan-starterkit/2.2.1/user-guide/architecture/?h=archi#background
F272,33,Azure/iotedge-lorawan-starterkit,"""Customers looking for an operated network with national or international reach (e.g. fleet operators, logistics) will tend to choose this setup accepting the potentially higher complexity and dependency on the network operator.""",Flexibility,https://azure.github.io/iotedge-lorawan-starterkit/2.2.1/user-guide/architecture/?h=archi#background
F273,33,Azure/iotedge-lorawan-starterkit,"""However, customers looking for any of the following are expected to prefer a setup where the LoRaWAN network servers runs directly on the gateway/Azure IoT Edge:  Primarily  coverage on their own ground (e.g. manufacturing plants, smart buildings, facilities, ports).  Capabilities that Azure IoT Edge brings to the table:  Local processing on the gateway. Offline capabilities of the gateway.  Gateway management. Homogenous management of devices and gateways independent of connectivity technology.""",Flexibility,https://azure.github.io/iotedge-lorawan-starterkit/2.2.1/user-guide/architecture/?h=archi#background
F274,35,Azure/KAN,"""KAN has three high-level components: portal, controller-API and agent. You can interact with KAN through its portal, Kubernetes tools like kubectl, and Azure Arc through GitOps.""",Compatibility,https://github.com/Azure/KAN?tab=readme-ov-file#how-it-works
F275,35,Azure/KAN,"""Portal provides an intuitive graphic interface for users to create, edit and manage their intelligent edge payloads. It offers an AI model zoo, a drag-n-drop AI skill editor, live camera previews and many other features.""",Interaction Capability,https://github.com/Azure/KAN?tab=readme-ov-file#how-it-works
F276,35,Azure/KAN,"""Controller-API is a Kubernetes operator that manages states of objects of a KAN API object model.""",Maintainability,https://github.com/Azure/KAN?tab=readme-ov-file#how-it-works
F277,35,Azure/KAN,"""Agent offers a number of services to edge payloads, such as retrieving new AI skill definitions and reporting object states.""",Reliability,https://github.com/Azure/KAN?tab=readme-ov-file#how-it-works
F278,35,Azure/KAN,"""A solution is the combination of an AI skill and custom containers (business logic), expressing the functional solution to your use case. Because your inputs to the portal ultimately run on a Kubernetes cluster (K8s), a solution is deployed from the K8s control plane to K8s nodes or a target.""",Flexibility,https://github.com/Azure/KAN/blob/main/docs/tutorial/concepts-kan.md#1-solutions
F279,35,Azure/KAN,"""You defined the target (compute device/cluster) in the first step. This is your Edge virtual machine (VM) where the AI applications are running. If there are K8s environments you want to run on IoT edge environments, you can expand your targets to include these environments, for example, K8s AKS HCI, K3s AKS-IoT, and Iot Edge devices such as EFLOW.""",Flexibility,https://github.com/Azure/KAN/blob/main/docs/tutorial/concepts-kan.md#2-targets
F280,35,Azure/KAN,"""A solution instance is the combination of a solution and a target. From the portal perspective, this is a deployment.""",Maintainability,https://github.com/Azure/KAN/blob/main/docs/tutorial/concepts-kan.md#3-solution-instances
F281,40,beclab/Olares,"""Olares supports different Kubernetes distributions depending on the underlying environment:      Linux environments (including WSL, PVE, LXC, Raspberry Pi): Users can choose to install Kubernetes or the lightweight K3s, with K3s being the default for its better performance and resource efficiency on local hardware.     macOS: minikube is used to deploy Kubernetes within a Linux virtual machine, ensuring a unified experience across platforms.""",Flexibility,https://docs.olares.xyz/manual/system-architecture.html#container-orchestration
F282,40,beclab/Olares,"""The networking stack ensures seamless communication between containers, nodes, and services. Key components include:      CoreDNS: Provides DNS services for the cluster, ensuring efficient name resolution.     Calico: A container networking interface (CNI) that facilitaes communication between containers and virtual machines while offering advanced network policy controls.     Envoy: A high-performance, extensible edge and service proxy.""",Compatibility,https://docs.olares.xyz/manual/system-architecture.html#networking
F283,40,beclab/Olares,"""Olares provides flexibility in storage solutions tailored to both single-node and multi-node setups:      Local storage (default): Ideal for single-node deployments, offering the best read/write performance.     S3: A cloud-based storage option. Ideal for cloud deployment via S3 or any S3-compatible service.     MinIO: A distributed storage solution for self-hosted deployment.""",Flexibility,https://docs.olares.xyz/manual/system-architecture.html#distributed-storage
F284,40,beclab/Olares,"""Olares leverages components like CUDA driver, NVIDIA device plugin, and nvShare, which work in conjunction to manage and provision GPU resources effectively.""",Performance Efficiency,https://docs.olares.xyz/manual/system-architecture.html#gpu-management
F285,40,beclab/Olares,"""Olares uses containerd, a lightweight container runtime, for containerized deployments.""",Performance Efficiency,https://docs.olares.xyz/manual/system-architecture.html#container-management
F286,40,beclab/Olares,"""Olares uses PostgreSQL 16 as its primary relational database. All applications share a single PostgreSQL instance, with each having dedicated accounts for isolation. PostgreSQL also serves as a full-text search engine and vector database.""",Reliability,https://docs.olares.xyz/manual/system-architecture.html#relational-database
F287,40,beclab/Olares,"""Olares integrates KVRocks, a Redis-compatible persistent key-value store built on RocksDB. KVRocks balances memory and disk storage, making it more resource-efficient than Redis clusters.""",Performance Efficiency,https://docs.olares.xyz/manual/system-architecture.html#key-value-cache
F288,40,beclab/Olares,"""Olares integrates NATS, a lightweight and high-performance message-oriented middleware, as the messaging system.""",Reliability,https://docs.olares.xyz/manual/system-architecture.html#message-queue
F289,40,beclab/Olares,"""Two secret management solutions are integrated into Olares:      Vault: Protects sensitive data like accounts, passwords, and mnemonics.     Infisical: A tool for managing sensitive information and preventing secret leaks in Olares development.""",Security,https://docs.olares.xyz/manual/system-architecture.html#secret-management
F290,40,beclab/Olares,"""Olares provides observability through the following:      Prometheus: Used for system monitoring and resource usage tracking.     OpenTelemetry: Enables tracing of request workflows within the Olares system using eBPF-based monitoring.""",Maintainability,https://docs.olares.xyz/manual/system-architecture.html#observability
F291,40,beclab/Olares,"""Olares uses LLDAP to manage user accounts and provide LDAP (Lightweight Directory Access Protocol) services for applications. Additionally, Authelia adds authentication and authorization support, including multi-factor authentication and single sign-on (SSO).""",Security,https://docs.olares.xyz/manual/system-architecture.html#authentication-and-authorization
F292,40,beclab/Olares,"""Olares employs JuiceFS, a cloud-native distributed file system, to provide POSIX-compatible interfaces for applications.""",Compatibility,https://docs.olares.xyz/manual/system-architecture.html#distributed-file-system
F293,47,citelab/JAMScript,"""JAMScript is based on a controller-worker model. The controllers can be at different levels: cloud, fog, and device levels. The workers can only be in the device level.""",Maintainability,https://citelab.github.io/JAMScript/jam-overview/
F294,47,citelab/JAMScript,"""JAMScript runtime is responsible for creating the hierarchical configuration among the controllers and workers at different levels. Therefore, JAMScript is highly suitable for creating and maintaining computing structures across collection of nodes that are constantly changing in proximity to one another  for example, vehicular networks.""",Flexibility,https://citelab.github.io/JAMScript/jam-overview/
F295,47,citelab/JAMScript,"""The JAMScript specific extensions allow the JAMScript compiler to relate both sides and make the necessary connections between the controller and worker so that both sides would work as a whole.""",Compatibility,https://citelab.github.io/JAMScript/jam-overview/
F296,47,citelab/JAMScript,"""One of the interesting aspects of JAMScript is the auto discovery of JAMScript program components. A JAMScript executable can be run in different ways: (a) only in a single device, (b) in a single fog and many devices, and (c) cloud, fog, and devices. There is no special configuration file to indicate which configuration is used at any invocation.""",Flexibility,https://citelab.github.io/JAMScript/jam-overview/
F297,47,citelab/JAMScript,"""Suppose we start a JAMScript program in a device and then in another device. The JAMScript programs in the two devices would run independent of each other  that is, without connecting with one another. Now, if we start a fog instance, all three instances would get connected  automatically!""",Reliability,https://citelab.github.io/JAMScript/jam-overview/
F298,47,citelab/JAMScript,"""Using a simple example scenario we illustrate some ways JAMScript can help the use of fog computing in mobile IoT. Let us consider a scenario where two fogs are located in a straight line (e.g., road segment). A vehicle is going back and forth on the road segment and we want it to be associated with the closest fog at any given time.""",Performance Efficiency,https://citelab.github.io/JAMScript/jam-overview/
F299,47,citelab/JAMScript,"""The tasks launched by the vehicle must get executed at the closest fog. Also, when the fogs execute remote tasks, the vehicles in their zones would execute those calls and not the vehicles in other fog zones.""",Performance Efficiency,https://citelab.github.io/JAMScript/jam-overview/
F300,47,citelab/JAMScript,"""The central component of the C runtime is the cnode. There are four major components inside the cnode: mqtt, data, tboard, and core.""",Maintainability,https://github.com/citelab/JAMScript/blob/master/lib/jside/docs/JAMScript-J-Design.docx
F301,47,citelab/JAMScript,"""The mqtt is responsible for interfacing with the MQTT brokers and all the remote calls go through this component.""",Compatibility,https://github.com/citelab/JAMScript/blob/master/lib/jside/docs/JAMScript-J-Design.docx
F302,47,citelab/JAMScript,"""The core is responsible for maintaining some foundational parameters of cnode. For example, each worker needs to have a unique ID, which is created the first time the node is executed.""",Reliability,https://github.com/citelab/JAMScript/blob/master/lib/jside/docs/JAMScript-J-Design.docx
F303,47,citelab/JAMScript,"""Workers expect at least one device-level controller to be in the local network. If there are multiple controllers in the local network, the workers need to have a way of selecting the controller to join.""",Security,https://github.com/citelab/JAMScript/blob/master/lib/jside/docs/JAMScript-J-Design.docx
F304,61,eclipse-kura/kura,"""Sparkplug is an open software specification that provides MQTT clients the framework to seamlessly integrate data from their applications, sensors, devices, and gateways within the MQTT Infrastructure.""",Compatibility,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/
F305,61,eclipse-kura/kura,"""This Cloud Connection assumes the role of Edge Node. The Edge Node is responsible for the interaction with the MQTT broker and that establishes sessions with the data-consuming Host Applications.""",Performance Efficiency,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#introduction-to-eclipse-sparkplug
F306,61,eclipse-kura/kura,"""Report by Exception (RBE): messages need to be sent by the Edge Node only when values at the edge change, and the message should contain only the value/metrics that changed.""",Performance Efficiency,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#introduction-to-eclipse-sparkplug
F307,61,eclipse-kura/kura,"""Birth and Death certificates: these messages represent the state of Edge Nodes and Devices (online/offline + data that will be reported).""",Reliability,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#introduction-to-eclipse-sparkplug
F308,61,eclipse-kura/kura,"""The Edge Node sets an MQTT Will message containing a NDEATH certificate. Doing so, if the MQTT broker does not receive any communication within the Keep Alive period (client lost connection), it will send the Edge Node NDEATH certificate on all subscribers.""",Security,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#session-management
F309,61,eclipse-kura/kura,"""This Cloud Connection maintains a persistent connection to the MQTT server.""",Reliability,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#introduction-to-eclipse-sparkplug
F310,61,eclipse-kura/kura,"""The Edge Node follows the required specification statements. In particular, multiple space-separated Server URIs can be specified in the component's configuration.""",Flexibility,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#data-transport-layer-configuration
F311,61,eclipse-kura/kura,"""The Sparkplug Data Transport layer bridges the incoming requests to the underlying Eclipse Paho MQTT v3.1.1 client following the Sparkplug specification.""",Compatibility,http://eclipse-kura.github.io/kura/docs-release-5.6/cloud-platform/kura-sparkplug/#data-transport-layer-configuration
F312,63,edgehog-device-manager/edgehog,"""Edgehog exposes two ways to interact with it: a frontend that can be used by users and a GraphQL API which can be used by third party applications to programmatically perform all actions that can be performed in the frontend.""",Interaction Capability,http://docs.edgehog.io/0.9/overview.html#user-interaction
F313,63,edgehog-device-manager/edgehog,"""Edgehog uses PostgreSQL to store its data. The database schema supports multiple tenants which are isolated at the database level. This makes it possible to use a single Edgehog instance with multiple tenants (e.g. in a SaaS scenario).""",Flexibility,http://docs.edgehog.io/0.9/overview.html#database-interaction
F314,63,edgehog-device-manager/edgehog,"""To interact with the other side of the domain (i.e. devices), Edgehog is built upon Astarte and it exchanges data with it using two of its mechanisms: its REST API and Astarte Triggers.""",Compatibility,http://docs.edgehog.io/0.9/overview.html#device-interaction-through-astarte
F315,63,edgehog-device-manager/edgehog,"""The interaction between Edgehog and Astarte is defined by a set of interfaces that define which data is sent both from Edgehog to the Devices and from the Devices towards Edgehog.""",Maintainability,http://docs.edgehog.io/0.9/overview.html#edgehog-astarte-interfaces
F316,63,edgehog-device-manager/edgehog,"""The REST API is called every time Edgehog needs to retrieve data contained in an Astarte interface or when it needs to send data to the Devices.""",Performance Efficiency,http://docs.edgehog.io/0.9/overview.html#astarte-appengine-api
F317,63,edgehog-device-manager/edgehog,"""Astarte Triggers are used to update the online state of the device. Each time a Device connects or disconnects from Astarte, Astarte Trigger Engine sends an HTTP POST request to the Edgehog backend, which in turn updates the Device online status in its own database.""",Reliability,http://docs.edgehog.io/0.9/overview.html#astarte-triggers
F318,83,Edgenesis/shifu,"""Shifu's foremost job is to make developers and operators happy.""",Interaction Capability,https://github.com/Edgenesis/shifu/blob/main/docs/design/design-shifu.md#human-centric
F319,83,Edgenesis/shifu,"""deviceShifu takes the form of a Kubernetes Pod, a digital representation or digital twin of a physical device.""",Functional Suitability,https://shifu.dev/docs/references/architecture/data-plane/#introduction
F320,83,Edgenesis/shifu,"""Shifu has been continuously adding new tools and services to ensure compatibility with different protocols and drivers.""",Maintainability,https://shifu.dev/docs/references/architecture/plug-ins/
F321,83,Edgenesis/shifu,"""It unifies different forms of requests from different devices, making it simpler for users to use the devices.""",Interaction Capability,https://shifu.dev/docs/references/architecture/#communication-with-devices
F322,83,Edgenesis/shifu,"""Shifu can be compatible with different communication protocols and drivers at the same time.""",Compatibility,https://shifu.dev/docs/references/architecture/#communication-with-devices
F323,83,Edgenesis/shifu,"""Shifu is a Kubernetes native platform with all its components running as Pods.""",Flexibility,https://shifu.dev/docs/references/architecture/#communication-with-devices
F324,84,EdgeVPNio/evio,"""EdgeVPN.io integrates several technologies and standards to deliver a flexible virtual network. These include NAT traversal, signaling, tunneling, network virtualization, overlay networking, and software-defined networking.""",Compatibility,https://edgevpn.io/architecture/#overview-and-terminology
F325,84,EdgeVPNio/evio,"""The overlay topology builds on a foundation established by the peer-to-peer research community. The key idea is to assign every vertex a unique identifier, and organize nodes in a ring structure ordered by these identifiers.""",Flexibility,https://edgevpn.io/architecture/#overlay-networking
F326,84,EdgeVPNio/evio,"""we can build the basic primitive upon which the whole systems is built - a peer-to-peer tunnel. This tunnel is private - data is encrypted before being sent over the tunnel, and decrypted on the other side.""",Security,https://edgevpn.io/architecture/#nat-traversal
F327,84,EdgeVPNio/evio,"""EdgeVPN.io builds on these standards, and leverages an open-source project (WebRTC) which implements this functionality.""",Performance Efficiency,https://edgevpn.io/architecture/#nat-traversal
F328,84,EdgeVPNio/evio,"""EdgeVPN.io integrates SDN technology as follows: 1) each TinCan links tap device is bound to a port of the OVS switch, and 2) a Ryu-based SDN controller is responsible for programming the OVS to handle frames that are either originating from the local computer or being received in one of its ports.""",Performance Efficiency,https://edgevpn.io/architecture/#software-defined-networking
F329,84,EdgeVPNio/evio,"""The node periodically queries STUN (and TURN, if configured) servers on the Internet to discover what public IP:port endpoint it might be reachable by other peers.""",Reliability,https://edgevpn.io/architecture/#putting-it-all-together
F330,93,FabEdge/fabedge,"""FabEdge builds a layer-3 data plane with tunnels in addition to the control plan managed by KubeEdge, SuperEdge, OpenYurt, etc.""",Performance Efficiency,https://github.com/FabEdge/fabedge?tab=readme-ov-file#how-it-works
F331,93,FabEdge/fabedge,"""Operator monitors k8s resources such as nodes, services, and endpoints in the cloud, and creates a configmap for each edge node, which contains the configuration information such as the subnet, tunnel, and load balancing rules.""",Maintainability,https://github.com/FabEdge/fabedge?tab=readme-ov-file#how-it-works
F332,93,FabEdge/fabedge,"""Connector is responsible to terminate the tunnels from edge nodes, and forward traffic between the cloud and the edge.""",Reliability,https://github.com/FabEdge/fabedge?tab=readme-ov-file#how-it-works
F333,93,FabEdge/fabedge,"""Cloud-Agent runs on the non-connector nodes in the cluster and manages the routes to remote peers.""",Performance Efficiency,https://github.com/FabEdge/fabedge?tab=readme-ov-file#how-it-works
F334,93,FabEdge/fabedge,"""Each edge node runs an agent and consumes its own configmap including the following functions: Manage the configuration file of the CNI plug-in of this node Manage the tunnels of this node Manage the load balancing rules of this node""","Flexibility, Interaction Capability",https://github.com/FabEdge/fabedge?tab=readme-ov-file#how-it-works
F335,93,FabEdge/fabedge,"""Fab-DNS runs in all the clusters, to provide the topology-aware service discovery capability by intercepting the DNS queries.""",Compatibility,https://github.com/FabEdge/fabedge?tab=readme-ov-file#how-it-works
F336,98,Fraunhofer-AISEC/trusted-connector,"""The isolation between Apps is based on the isolation between containers. The Core Container is a privileged container running the Core Container Stack, which takes care of all management and routing tasks.""",Security,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#app-isolation
F337,98,Fraunhofer-AISEC/trusted-connector,"""Support for x86 and Raspberry Pi (ARM) platforms.""",Flexibility,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#trusted-platform
F338,98,Fraunhofer-AISEC/trusted-connector,"""The Trusted Connector features the secure container management layer trust|me as an alternative to Docker. [...] For mandatory access control, trust|me adds a custom Linux Security Module (LSM) to the Linux kernel.""",Security,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#trusted-platform
F339,98,Fraunhofer-AISEC/trusted-connector,"""Every connector needs a certificate issued by the Device-CA. This certificate serves as the root of identity. The contents of this certificate are kept at minimum to avoid the need for later revocation in case of changing attributes.""",Security,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#cross-enterprise-identity-management
F340,98,Fraunhofer-AISEC/trusted-connector,"""Data is labeled by LUCON as soon as it is processed by the Connector. While the data is processed by a data route, these labels are transported along with the data and, depending on the defined policies, are removed, transformed or extended.""",Security,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#data-usage-control
F341,98,Fraunhofer-AISEC/trusted-connector,"""The IDSC protocol establishes trust and sets up a secure messaging channel between Trusted Connectors.""",Reliability,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#trusted-platform
F342,98,Fraunhofer-AISEC/trusted-connector,"""Usage Control influences how data may be processed throughout its lifetime. [...] Data usage can be limited or invalid data flows can be suppressed.""",Security,https://industrial-data-space.github.io/trusted-connector-documentation/docs/overview/#data-usage-control
F343,116,inngest/inngest,"""The system is composed of the following services: Event API, Event stream, Runner, Queue, Executor, State store, Database, API, Dashboard UI.""",Performance Efficiency,https://www.inngest.com/docs/self-hosting#inngest-system-architecture
F344,116,inngest/inngest,"""By default, the signing key adds the following: Authentication: requests to your endpoint are authenticated, ensuring that they originate from Inngest. Replay attack prevention: requests are signed with a timestamp embedded.""",Security,https://www.inngest.com/docs/learn/security#signing-keys-and-sdk-security
F345,116,inngest/inngest,"""End-to-end encryption is a middleware which intercepts requests, responses, and SDK logic on your own servers.""",Security,https://www.inngest.com/docs/learn/security#end-to-end-encryption
F346,116,inngest/inngest,"""The Functions list page provides the first round of essential information in one place with: Triggers, Failure rate, Volume.""",Maintainability,https://www.inngest.com/docs/platform/monitor/observability-metrics#function-runs-observability
F347,116,inngest/inngest,"""Branch Environments are sandbox environments that enable developers on your team to test your changes specific to current Git feature branch.""",Interaction Capability,https://www.inngest.com/docs/platform/environments
F348,116,inngest/inngest,"""In order to run your functions, they must be synced, or registered, with your Inngest account. This is required for Inngest to know which functions your application is serving and the configuration of each function.""",Reliability,https://www.inngest.com/docs/learn/security#function-registration-handshake
F349,120,intel/AiCSD,"""The reference implementation offers an architecture of microservices connected by a secure Redis Message Broker and various communication APIs.""",Performance Efficiency,https://intel.github.io/AiCSD/index.html#ai-connect-for-scientific-data-aicsd
F350,120,intel/AiCSD,"""The reference implementation uses the APIs from the EdgeX Applications Services to communicate and transfer information.""",Compatibility,https://intel.github.io/AiCSD/index.html#ai-connect-for-scientific-data-aicsd
F351,120,intel/AiCSD,"""The reference implementation furnishes an example pipeline for pipeline management.""","Functional Suitability, Performance Efficiency",https://intel.github.io/AiCSD/index.html#ai-connect-for-scientific-data-aicsd
F352,120,intel/AiCSD,"""AiCSD uses the TIG stack in the implementation of the health monitoring feature.""",Maintainability,https://github.com/intel/AiCSD/blob/main/docs_src/monitoring/overview.md#overview
F353,120,intel/AiCSD,"""The custom pipeline sends information to the reference implementation Task Manager via REST.""",Security,https://github.com/intel/AiCSD/blob/main/docs_src/pipelines/pipeline-creation.md#pipeline-creation
F354,120,intel/AiCSD,"""Communication between the pipeline and the reference implementation occurs through both the EdgeX Message Bus using Redis Pub/Sub and REST calls.""",Flexibility,https://github.com/intel/AiCSD/blob/main/docs_src/pipelines/pipeline-creation.md#overview
F355,120,intel/AiCSD,"""To view the default system health dashboard on the Grafana UI, open a browser to http://localhost:3001.""",Interaction Capability,https://github.com/intel/AiCSD/blob/main/docs_src/monitoring/overview.md#view-system-health
F356,137,keylime/keylime,"""Keylime mainly consists of an agent, two server components (verifier and registrar) and a commandline tool the tenant.""",Maintainability,https://keylime.readthedocs.io/en/latest/design/overview.html#overview-of-keylime
F357,137,keylime/keylime,"""The agent registers itself in the registrar. The registrar manages the agent enrollment process which includes getting an UUID for the agent, collecting the EKpub, EK certificate and AKpub from an agent and verifying that the AK belongs to the EK.""",Security,https://keylime.readthedocs.io/en/latest/design/overview.html#registrar
F358,137,keylime/keylime,"""It is possible for the agent to listen to revocation events that are sent by the verifier if an agent attestation failed. This is useful for environments where attested systems directly communicate with each other and require that the other systems are trusted.""",Reliability,https://keylime.readthedocs.io/en/latest/design/overview.html#agent
F359,137,keylime/keylime,"""Keylime allows to verify files measured by IMA against either a provided allowlist or a signature. This makes it for example easy to attest all files that were executed by root.""",Security,https://keylime.readthedocs.io/en/latest/design/overview.html#ima-validation
F360,137,keylime/keylime,"""To make attestation still possible Keylime includes a policy engine for validating the UEFI event log.""",Reliability,https://keylime.readthedocs.io/en/latest/design/overview.html#measured-boot-using-the-uefi-event-log
F361,137,keylime/keylime,"""The tenant is a commandline management tool shipped by Keylime to manage agents. This includes adding or removing the agent from attestation, validation of the EK certificate against a cert store and getting the status of an agent.""",Interaction Capability,https://keylime.readthedocs.io/en/latest/design/overview.html#tenant
F362,149,Luos-io/luos_engine,"""Luos engine is the engine provided by Luos that will manage your services on all your nodes. Technically, this engine is an embedded oriented lightweight and real-time ANSI C code library that you can include and use in your code.""",Performance Efficiency,https://www.luos.io/docs/luos-technology/basics/concepts#luos-engine
F363,149,Luos-io/luos_engine,"""A node is an executable software running Luos and hosting one or several services. It can be running on a microcontroller, a computer, or in the cloud.""",Maintainability,https://www.luos.io/docs/luos-technology/basics/concepts#what-is-a-node
F364,149,Luos-io/luos_engine,"""Services in the network are automatically detected and being assigned IDs depending on their node's physical position in the network, and a routing table is generated.""",Compatibility,https://www.luos.io/docs/luos-technology/basics/concepts#service-detection
F365,149,Luos-io/luos_engine,"""Communication between services and apps is performed through messages. A message contains information on the destination service(s), the type of operation to be performed (the type of message), as well as the data.""",Reliability,https://www.luos.io/docs/luos-technology/basics/concepts#messages
F366,149,Luos-io/luos_engine,"""Services can have the following accessibility: READ_WRITE_ACCESS, READ_ONLY_ACCESS, WRITE_ONLY_ACCESS, NO_ACCESS.""",Security,https://www.luos.io/docs/luos-technology/services/create-services#services-accessibility
F367,149,Luos-io/luos_engine,"""You can choose between the different communication bus already provided by Luos or create your own.""",Flexibility,https://www.luos.io/docs/luos-technology/basics/concepts#what-is-a-node
F368,149,Luos-io/luos_engine,"""A driver service never depends on or uses any other services (driver or app). A driver service is 'dumb', as it can't do anything else than manage its hardware feature (but it does it very well).""",Maintainability,https://www.luos.io/docs/luos-technology/services/create-services#drivers-guidelines
F369,150,macchina-io/macchina.io,"""mqtt.clients.eclipse.serverURI = tcp://mqtt.eclipseprojects.io:1883 mqtt.clients.eclipse.clientId = ${system.nodeId}""",Performance Efficiency,https://docs.macchina.io/edge/00400-MQTTProgramming.html
F370,150,macchina-io/macchina.io,"""macchina.io EDGE implements various protocols for talking to sensor networks, automation systems, or cloud services. One such protocol is MQTT, a publish-subscribe based 'light weight' messaging protocol.""",Compatibility,https://docs.macchina.io/edge/00100-MacchinaIntroduction.html
F371,150,macchina-io/macchina.io,"""macchina.io EDGE has been built in a very modular and extensible way.""",Maintainability,https://docs.macchina.io/edge/00100-MacchinaIntroduction.html
F372,150,macchina-io/macchina.io,"""The user interface of macchina.io EDGE is entirely web-based. It is implemented using the web server built into OSP.""",Interaction Capability,https://docs.macchina.io/edge/00100-MacchinaIntroduction.html
F373,150,macchina-io/macchina.io,"""The Open Service Platform (OSP) enables the creation, deployment and management of dynamically extensible, modular applications.""",Flexibility,https://docs.macchina.io/edge/00100-MacchinaIntroduction.html
F374,150,macchina-io/macchina.io,"""macchina.io EDGE defines generic interfaces for various kinds of sensors and devices.""",Maintainability,https://docs.macchina.io/edge/00100-MacchinaIntroduction.html
F375,150,macchina-io/macchina.io,"""Services for publish-subscribe based communication with browser-based applications using web sockets (WebEvent).""",Maintainability,https://docs.macchina.io/edge/00100-MacchinaIntroduction.html
F376,153,microsoft/azure_arc,"""We embrace a modular automation philosophy akin to Lego-like coding. Our content is designed to be reusable, comprehensive, repeatable, and above all, reliable.""",Maintainability,https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md#our-philosophy-and-core-design-principles
F377,153,microsoft/azure_arc,"""If it can or should be automated, rest assured, it will be automated. We believe in the power of automation, streamlining processes, and simplifying complex tasks.""",Performance Efficiency,https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md#our-philosophy-and-core-design-principles
F378,153,microsoft/azure_arc,"""Arc Jumpstart accommodates your infrastructure, whether it resides on-premises or in the cloud.""",Compatibility,https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md#our-mission-and-principles-empowering-seamless-azure-adaptive-cloud-adoption
F379,153,microsoft/azure_arc,"""Step-by-step instructions are provided, catering to users of all levels.""",Interaction Capability,https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md
F380,153,microsoft/azure_arc,"""Detailed screenshots provide visual context, enhancing your learning experience and making complex topics more accessible""",Interaction Capability,https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md
F381,153,microsoft/azure_arc,"""We pledge to support, advocate, and contribute to these projects, fostering an environment of mutual growth and innovation.""",Flexibility,https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md#our-commitment-to-the-open-source-community-elevating-excellence-together
F382,153,microsoft/azure_arc,"""Our extensive automation and scripting for scenarios and features undergo rigorous code reviews and testing, ensuring a standard of excellence.""","Security, Reliability",https://github.com/Azure/arc_jumpstart_docs/blob/main/docs/mission/_index.md#our-commitment-to-the-open-source-community-elevating-excellence-together
F383,166,nabto/nabto-embedded-sdk,"""Finally, it is best practice to verify the device authenticity when connecting: The device public key fingerprint is compared to what is cached from the pairing step: The devices fingerprint is available to the client application after the connection is established.""",Reliability,https://docs.nabto.com/developer/platforms/common/connect.html
F384,166,nabto/nabto-embedded-sdk,"""Server Connect Token (SCT): This is a random string shared between client, device and basestation. The basestation uses this to prevent DoS attacks on devices.""",Security,https://docs.nabto.com/developer/platforms/common/connect.html
F385,166,nabto/nabto-embedded-sdk,"""A Nabto connection is based on UDP packets. To keep firewalls open for packets and to detect network failure, keep-alive packets are used.""",Performance Efficiency,https://docs.nabto.com/developer/platforms/common/connect.html
F386,166,nabto/nabto-embedded-sdk,"""Client application development is supported through high level SDKs on iOS and Android. Lower level C-based SDKs are available on Windows, macOS and Linux.""",Compatibility,https://docs.nabto.com/developer/platforms/common/intro.html
F387,166,nabto/nabto-embedded-sdk,"""You can use Device Discovery to connect to local devices you do not yet know the id of.""",Interaction Capability,https://docs.nabto.com/developer/platforms/common/intro.html
F388,167,nanomq/nanomq,"""Message Persistence: Preserve your business-critical data with built-in data persistence, and resume uploading automatically when the connection is restored.""",Reliability,https://nanomq.io/docs/en/latest/#key-features
F389,167,nanomq/nanomq,"""Blazing Fast: Achieve million-level TPS. Up to 10 times faster than Mosquitto on a multi-core CPU.""",Performance Efficiency,https://nanomq.io/docs/en/latest/#why-nanomq
F390,167,nanomq/nanomq,"""Multi-threading: Scale out easily to engage multiple cores with less CPU usage in the modern SMP system.""",Flexibility,https://nanomq.io/docs/en/latest/#why-nanomq
F391,167,nanomq/nanomq,"""Multi-Language Protocol: Support multiple protocols such as ZeroMQ/nanomsg/NNG/WebSocket.""",Compatibility,https://nanomq.io/docs/en/latest/#key-features
F392,167,nanomq/nanomq,"""Secure your IoT connections with TLS/SSL.""",Security,https://nanomq.io/docs/en/latest/#key-features
F393,167,nanomq/nanomq,"""Rule Engine: Unlock the flexibility of data with a SQL-based rule engine. Integrates with eKuiper to bring stream processing to the edge.""",Maintainability,https://nanomq.io/docs/en/latest/#key-features
F394,167,nanomq/nanomq,"""Cross-platform: Highly compatible and portable with any POSIX-based platform.""",Flexibility,https://nanomq.io/docs/en/latest/#why-nanomq
F395,182,opendatahub-io/ai-edge,"""Manages the near edge clusters and the AI/ML inference deployed on them in a GitOps manner using Red Hat Advanced Cluster Management for Kubernetes (ACM) and Red Hat OpenShift GitOps.""",Maintainability,https://github.com/opendatahub-io/ai-edge?tab=readme-ov-file#core-cluster
F396,182,opendatahub-io/ai-edge,"""Monitors and observes the deployed AI/ML inference workloads in the near edge environments using ACM and Red Hat OpenShift Observability.""",Flexibility,https://github.com/opendatahub-io/ai-edge?tab=readme-ov-file#core-cluster
F397,182,opendatahub-io/ai-edge,"""Packages different types of AI/ML models and serving runtimes into container images using Red Hat OpenShift Pipelines.""",Performance Efficiency,https://github.com/opendatahub-io/ai-edge?tab=readme-ov-file#core-cluster
F398,182,opendatahub-io/ai-edge,"""Continuously reconcile the state of the AI/ML workloads with the core cluster using ACM's pull model with Argo CD.""",Reliability,https://github.com/opendatahub-io/ai-edge?tab=readme-ov-file#near-edge-clusters
F399,182,opendatahub-io/ai-edge,"""Collect metrics of the AI/ML workloads and send them to the core cluster using Red Hat OpenShift Observability and ACM.""",Compatibility,https://github.com/opendatahub-io/ai-edge?tab=readme-ov-file#near-edge-clusters
F400,183,openshift/microshift,"""MicroShift is safe to change; it has means to automatically recover from faulty software or configuration updates that would render it unmanageable or non-operational.""",Reliability,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#design-goals
F401,183,openshift/microshift,"""MicroShift makes frugal use of system resources. It runs on <1GB RAM and <1 CPU core (Intel Atom- or ARM Cortex-class).""",Performance Efficiency,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#design-goals
F402,183,openshift/microshift,"""MicroShift does not require Kubernetes-expertise to configure, deploy, or lifecycle-manage it; Linux admins will find it behaves like any other Linux workload.""",Interaction Capability,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#design-goals
F403,183,openshift/microshift,"""MicroShift instances should run with least privileges."" ""MicroShift should minimize the number of open network ports.""",Security,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#security
F404,183,openshift/microshift,"""MicroShift is binary compatible with OpenShift and Kubernetes conforming.""",Maintainability,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#design-goals
F405,183,openshift/microshift,"""Minimal core: We keep MicroShift to a minimal set of functionality, but provide mechanisms for extension.""",Maintainability,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#design-principles
F406,183,openshift/microshift,"""MicroShift works seamlessly under adverse network conditions (e.g. disconnected or rarely connected, NAT'ed or firewalled, changing IP addresses, high latency, low bandwidth).""",Reliability,https://github.com/openshift/microshift/blob/main/docs/contributor/design.md#design-goals
F407,184,openvinotoolkit/model_server,"""OpenVINO Model Server can be scaled vertically by adding more resources or horizontally by adding more instances of the service on multiple hosts.""",Flexibility,https://github.com/openvinotoolkit/model_server/blob/main/docs/performance_tuning.md#scalability
F408,184,openvinotoolkit/model_server,"""They allow employing a dynamic library developed in C++ or C to perform arbitrary data transformations.""",Reliability,https://github.com/openvinotoolkit/model_server/blob/main/docs/custom_node_development.md#overview
F409,184,openvinotoolkit/model_server,"""By default, the OpenVINO Model Server containers start with the security context of a local account ovms with Linux UID 5000.""",Security,https://github.com/openvinotoolkit/model_server/blob/main/docs/security_considerations.md#security-considerations
F410,184,openvinotoolkit/model_server,"""The model format for the deployment is identical regardless of the employed accelerators.""",Interaction Capability,https://github.com/openvinotoolkit/model_server/blob/main/docs/accelerators.md#prepare-test-model
F411,184,openvinotoolkit/model_server,"""OpenVINO Model Server can be tuned to a single client use case or a high concurrency.""",Maintainability,https://github.com/openvinotoolkit/model_server/blob/main/docs/performance_tuning.md#adjusting-the-number-of-streams-in-cpu-and-gpu-target-devices
F412,184,openvinotoolkit/model_server,"""The PERFORMANCE_HINT plugin config property enables you to specify a performance mode for the plugin.""",Performance Efficiency,https://github.com/openvinotoolkit/model_server/blob/main/docs/performance_tuning.md#performance-hints
F413,184,openvinotoolkit/model_server,"""The execute function should not modify the buffers storing the input data because that would alter the data which potentially might be used in other pipeline nodes.""",Reliability,https://github.com/openvinotoolkit/model_server/blob/main/docs/custom_node_development.md#execute-function
F414,201,roflcoopter/viseron,""":::warning The implementation has not been audited by security experts. If you plan to expose Viseron to the internet I suggest coupling it with alternate authentication methods as well, such as Cloudflare Access or a VPN.""",Security,https://github.com/roflcoopter/viseron/blob/dev/docs/docs/documentation/configuration/authentication.md#authentication
F415,201,roflcoopter/viseron,"""At the moment there is no way to add more users through the web interface. This will be added in a future release.""",Interaction Capability,https://github.com/roflcoopter/viseron/blob/dev/docs/docs/documentation/configuration/authentication.md#adding-more-users
F416,201,roflcoopter/viseron,"""If you forget your password, you can reset it by deleting these files: /config/.viseron/onboarding /config/.viseron/auth After a restart, Viseron will once again prompt you to create an admin user.""",Reliability,https://github.com/roflcoopter/viseron/blob/dev/docs/docs/documentation/configuration/authentication.md#resetting-the-password
F417,201,roflcoopter/viseron,"""Viserons config consists of components. Every component provides different sets of domains (such as cameras, object detection, motion detection etc). These domains are then tied together, providing the full capabilities of Viseron.""",Maintainability,https://github.com/roflcoopter/viseron/blob/dev/docs/docs/documentation/configuration/components.md#components
F418,201,roflcoopter/viseron,"""You can mix and match components freely. For example you could use different object detectors for different cameras.""",Maintainability,https://github.com/roflcoopter/viseron/blob/dev/docs/docs/documentation/configuration/components.md#components
F419,203,saltstack/salt,"""A common source of confusion is determining when messages are passed in the clear and when they are passed using encryption. There are two rules governing this behaviour:      ClearFuncs is used for intra-master communication and during the initial authentication handshake between a minion and master during the key exchange.     AESFuncs is used everywhere else.""",Security,https://github.com/saltstack/salt/blob/master/doc/topics/development/architecture.rst#a-note-on-clearfuncs-vs-aesfuncs
F420,203,saltstack/salt,"""The salt-minion may fork other processes as required to do the work without blocking the main salt-minion process and this necessitates a mechanism by which those processes can communicate with each other.""",Reliability,https://github.com/saltstack/salt/blob/master/doc/topics/development/architecture.rst#event-system
F421,203,saltstack/salt,"""The number of workers is equivalent to the number of 'worker_threads' specified in the master configuration and is always at least one.""",Performance Efficiency,https://github.com/saltstack/salt/blob/master/doc/topics/development/architecture.rst#mworker
F422,203,saltstack/salt,"""Salt features a pluggable transport system to issue commands from a master to minions. The default transport is ZeroMQ.""",Maintainability,https://github.com/saltstack/salt/blob/master/doc/topics/development/architecture.rst#overview
F423,203,saltstack/salt,"""When a Salt master starts up, a number of processes are started, all of which are called 'salt-master' in a process-list but have various role categories.""",Maintainability,https://github.com/saltstack/salt/blob/master/doc/topics/development/architecture.rst#moving-pieces
F424,204,scaleoutsystems/fedn,"""By horizontally scaling the number of combiners, one can meet the needs of a growing number of clients.""",Flexibility,https://docs.scaleoutsystems.com/en/stable/architecture.html#architecture-overview
F425,204,scaleoutsystems/fedn,"""Importantly, clients uses remote procedure calls (RPC) to ask for model updates tasks, thus the clients not require any open ingress ports!""",Security,https://docs.scaleoutsystems.com/en/stable/architecture.html#architecture-overview
F426,204,scaleoutsystems/fedn,"""The package is based on entry points in the client code, and can be customized to fit the needs of the user. This allows for a high degree of flexibility in terms of what kind of training and validation tasks that can be performed on the client side.""",Flexibility,https://docs.scaleoutsystems.com/en/stable/architecture.html#architecture-overview
F427,204,scaleoutsystems/fedn,"""A combiner is an actor whose main role is to orchestrate and aggregate model updates from a number of clients during a training session.""",Maintainability,https://docs.scaleoutsystems.com/en/stable/architecture.html#architecture-overview
F428,204,scaleoutsystems/fedn,"""Tier 3 also contain a Reducer component, which is responsible for aggregating combiner-level models into a single global model. Further, it contains a StateStore database, which is responsible for storing various states of the network and training sessions.""",Reliability,https://docs.scaleoutsystems.com/en/stable/architecture.html#architecture-overview
F429,207,sensiml/piccolo,"""The MQTT-SN Interface has been replaced with the new Simple Streaming format. We still support the MQTT-SN interface, but we will not be maintaining or adding any new features going forward.""",Maintainability,https://github.com/sensiml/piccolo/blob/main/docs/source/mqtt-specification/introduction.rst#mqtt-sn-introduction
F430,207,sensiml/piccolo,"""To support a seamless experience across a variety of hardware platforms we needed a hardware-agnostic specification to manage sensors across an IoT stack.""",Flexibility,https://github.com/sensiml/piccolo/blob/main/docs/source/mqtt-specification/introduction.rst#mqtt-sn-introduction
F431,207,sensiml/piccolo,"""By using MQTT and MQTT-SN protocols, it is possible to reuse the code and the overall code footprint can be minimized for the devices that have to retain dev-time and run-time protocol functionality.""",Performance Efficiency,https://github.com/sensiml/piccolo/blob/main/docs/source/mqtt-specification/introduction.rst#overview
F432,207,sensiml/piccolo,"""The application messaging for this interface specification uses the well established MQTT and MQTT-SN protocols to interface with host applications or IoT cloud platforms.""",Compatibility,https://github.com/sensiml/piccolo/blob/main/docs/source/mqtt-specification/introduction.rst#overview
F433,207,sensiml/piccolo,"""At a minimum, this involves basic connectivity for controlling the collection and data logging of sensor data from the hardware platform.""",Reliability,https://github.com/sensiml/piccolo/blob/main/docs/source/mqtt-specification/introduction.rst#objectives
F434,210,simpleiot/simpleiot,"""With any long running process, it is important to not only Start it, but also to be able to cleanly Stop it. This is important for testing, but is also good practice. Nothing runs forever so we should never operate under this illusion.""",Reliability,https://github.com/simpleiot/simpleiot/blob/master/docs/ref/architecture-app.md#application-lifecycle
F435,210,simpleiot/simpleiot,"""The simplicity of this architecture makes it easy to extend with new functionality by writing a new client.""",Maintainability,https://github.com/simpleiot/simpleiot/blob/master/docs/ref/architecture-app.md#application-architecture
F436,210,simpleiot/simpleiot,"""This project uses NATS.io for messaging. Some reasons: allows us to push realtime data to an edge device behind a NAT, on cellular network, etc -- no public IP address, VPN, etc required. is more efficient than HTTP as it shares one persistent TCP connection for all messages.""",Performance Efficiency,https://github.com/simpleiot/simpleiot/blob/master/docs/ref/architecture-system.md#device-communication-and-messaging
F437,210,simpleiot/simpleiot,"""Clients can exist inside the Simple IoT application or as external processes written in any language that connect via NATS.""",Compatibility,https://github.com/simpleiot/simpleiot/blob/master/docs/ref/architecture-app.md#application-architecture
F438,217,smartfog/fogflow,"""FogFlow is a distributed execution framework to dynamically orchestrate IoT services over cloud and edges, in order to reduce internal bandwidth consumption and offer low latency and fast response time.""",Performance Efficiency,https://github.com/smartfog/fogflow/blob/development/docs/en/source/introduction.rst
F439,217,smartfog/fogflow,"""By providing automated and optimized IoT service orchestration with high scalability and reliability, FogFlow helps infrastructure providers to largely reduce their operation cost.""",Reliability,https://github.com/smartfog/fogflow/blob/development/docs/en/source/introduction.rst
F440,217,smartfog/fogflow,"""FogFlow provides a standard-based and data-centric edge programming model for IoT service providers to easily and fast realize their services for various business demands.""",Maintainability,https://github.com/smartfog/fogflow/blob/development/docs/en/source/introduction.rst#technical-benefit
F441,217,smartfog/fogflow,"""based on the standardized and unified data model and communicatino interface, namely NGSI, FogFlow is able to see the content of all data generated by sensors and data processing tasks in the system""",Compatibility,https://github.com/smartfog/fogflow/blob/development/docs/en/source/introduction.rst#high-level-view
F442,217,smartfog/fogflow,"""For example, for service consumers, they can specify which type of results are expected under which type of QoS within which geo-scope; for data providers, they can specify how their data should be utilized by whom.""",Security,https://github.com/smartfog/fogflow/blob/development/docs/en/source/introduction.rst#high-level-view
F443,225,thin-edge/thin-edge.io,"""The primary goal of thin-edge.io is to simplify the connection of edge devices to the cloud by providing a secure and reliable cloud connectivity as well as a device management agent.""",Security,https://thin-edge.github.io/thin-edge.io/understand/faq/#design-principles
F444,225,thin-edge/thin-edge.io,"""The main motivation to use Rust is security: Rust avoids many security vulnerabilities and threading issues at compile time. With the type system of Rust you write software that is free from typical security flaws: undefined behavior, data races or any memory safety issues.""",Security,https://thin-edge.github.io/thin-edge.io/understand/faq/#why-use-rust
F445,225,thin-edge/thin-edge.io,"""Reliability - thin-edge.io components can survive in chaotic environments as network outages and process restarts happen.""",Reliability,https://thin-edge.github.io/thin-edge.io/understand/faq/#design-principles
F446,225,thin-edge/thin-edge.io,"""Efficiency - thin-edge.io lets users build applications that can run on constrained device hardware and with limited bandwidth networks.""",Performance Efficiency,https://thin-edge.github.io/thin-edge.io/understand/faq/#design-principles
F447,225,thin-edge/thin-edge.io,"""Interoperability - thin-edge.io lets the users integrate components producing or consuming telemetry data, northbound with cloud platforms, southbound with sensors as well as for east-west communication between analytics components.""",Compatibility,https://thin-edge.github.io/thin-edge.io/understand/faq/#design-principles
F448,225,thin-edge/thin-edge.io,"""MQTT client libraries are available for 25+ programming languages (see MQTT.org]).""",Compatibility,https://thin-edge.github.io/thin-edge.io/understand/faq/#why-does-thin-edgeio-use-mqtt-for-ipc
F449,225,thin-edge/thin-edge.io,"""Using an IPC mechanism (and not a library) makes it easier to dynamically plug together components during runtime (instead of recompiling the software).""",Maintainability,https://thin-edge.github.io/thin-edge.io/understand/faq/#why-is-thin-edgeio-an-executable-binary-and-not-a-library
F450,225,thin-edge/thin-edge.io,"""Multi-cloud - thin-edge.io enables users to connect their edge devices with multiple clouds. The actual cloud used can be decided at run-time by the end-user.""",Flexibility,https://thin-edge.github.io/thin-edge.io/understand/faq/#design-principles
F451,235,TRUMPF-IoT/saf,"""A distributed application built upon the Service Application Framework (SAF) consists at least of two things: A SAF Host and a SAF Plug-in. The SAF Host is responsible for loading and initializing the SAF Infrastructure Services and for loading and initializing the SAF Plug-ins.""",Maintainability,https://github.com/TRUMPF-IoT/saf/blob/master/docs/index.md#overview
F452,235,TRUMPF-IoT/saf,"""The Main Container stores the Infrastructure Services that are shared with the Plug-ins because they are added to the Plug-in specific DI containers as well.""",Maintainability,https://github.com/TRUMPF-IoT/saf/blob/master/docs/diContainerOverview.md#saf-dependency-injection-di-container-overview
F453,235,TRUMPF-IoT/saf,"""SAFs messaging infrastructure provides a pub/sub messaging service used from SAF Plug-ins to communicate with each other.""",Compatibility,https://github.com/TRUMPF-IoT/saf/blob/master/docs/infrastructureAndToolboxServices.md#messaging-infrastructure
F454,235,TRUMPF-IoT/saf,"""Communication between plug-ins running in the same host instance as well as the communication between plug-ins running in different SAF Host instances is done through SAFs messaging infrastructure, which mainly provides a pub/sub messaging service.""",Reliability,https://github.com/TRUMPF-IoT/saf/blob/master/docs/infrastructureAndToolboxServices.md#saf-infrastructure-services
F455,235,TRUMPF-IoT/saf,"""SAF runs on .NET Core and can easily be integrated into ASP.NET Core applications.""",Flexibility,https://github.com/TRUMPF-IoT/saf/blob/master/docs/index.md#smart-application-framework-saf
F456,235,TRUMPF-IoT/saf,"""SAFs storage infrastructure provides a service to store key/value pairs. The storage is local to one single SAF Host and can be used by all Plug-ins loaded from that host instance.""",Performance Efficiency,https://github.com/TRUMPF-IoT/saf/blob/master/docs/infrastructureAndToolboxServices.md#storage-infrastructure
F457,241,WasmEdge/WasmEdge,"""WasmEdge is a standalone WebAssembly runtime where all WebAssembly bytecode runs independently within this execution sandbox, rather than being managed by the OS. Access to system resources, whether files, hardware, or internet connections, can only be achieved through the WebAssembly system interfaces provided by this virtual machine.""",Security,https://github.com/WasmEdge/WasmEdge/blob/master/docs/self-assessment.md#security-functions-and-features
F458,241,WasmEdge/WasmEdge,"""The WasmEdge ecosystem can be separated into the above layers: Core, Plug-ins, Tools, and Language supports.""",Maintainability,https://github.com/WasmEdge/WasmEdge/blob/master/docs/ecosystem.md#introduction
F459,241,WasmEdge/WasmEdge,"""WasmEdge follows a 90 days disclosure timeline. For known public security vulnerabilities, we will disclose the disclosure as soon as possible after receiving the report.""",Reliability,https://github.com/WasmEdge/WasmEdge/blob/master/docs/self-assessment.md#security-issue-resolution
F460,241,WasmEdge/WasmEdge,"""WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime. It is the fastest Wasm VM today.""",Performance Efficiency,https://github.com/WasmEdge/WasmEdge/blob/master/docs/self-assessment.md#overview
F461,241,WasmEdge/WasmEdge,"""The pull request must be approved by WasmEdge maintainer, committer or reviewers before merge. The pull request must pass the CI jobs before merge.""",Maintainability,https://github.com/WasmEdge/WasmEdge/blob/master/docs/self-assessment.md#secure-development-practices
F462,242,watson-intu/self,"""The body.json is eventually going away in future releases to be replaced by a cloud based graph.""",Maintainability,https://github.com/watson-intu/self-docs/blob/94f376527082cfd25c225b2f99a5304d6955576f/faqs/architecture/architecture.md
F463,242,watson-intu/self,"""According to the Self architecture document, the different subsystems (sensors, models, actuators, agency) have their own blackboard. Are these blackboard separated? If yes, do their agents talk to one another in the same environment?",Maintainability,https://github.com/watson-intu/self-docs/blob/94f376527082cfd25c225b2f99a5304d6955576f/faqs/architecture/architecture.md
F464,242,watson-intu/self,"""We are working to allow a single Intu instance in the cloud to handle a large number of users at the same time.""",Reliability,https://github.com/watson-intu/self-docs/blob/94f376527082cfd25c225b2f99a5304d6955576f/faqs/architecture/architecture.md
F465,242,watson-intu/self,"""Sometimes some services we communicate with can act as orchestration layers. However, usually we handle orchestration within an agent inside Intu.""",Performance Efficiency,https://github.com/watson-intu/self-docs/blob/94f376527082cfd25c225b2f99a5304d6955576f/faqs/architecture/architecture.md
F466,247,Xilinx/Vitis-AI,"""Vitis AI 3.5 supports Zynq Ultrascale+ and Versal AI Core architectures, however the IP for these devices is now considered mature and will not be updated with each release. Users should understand that we will continue to support these targets into the future and Vitis AI will update the pre-built board images and reference designs for these architectures with each major release (ie, 4.0).""",Flexibility,https://xilinx.github.io/Vitis-AI/3.5/html/docs/workflow.html?highlight=architecture#supported-evaluation-targets
F467,247,Xilinx/Vitis-AI,"""In the early stages of evaluation, it is recommended that developers obtain and leverage a supported Vitis AI target platform. Several AMD evaluation platforms are directly supported with pre-built SD card images that enable the developer to evaluate the Vitis AI workflow. Because these images are ready-to-use, there is no immediate need for the developer to master the integration of the DPU IP.""",Interaction Capability,https://xilinx.github.io/Vitis-AI/3.5/html/docs/workflow.html?highlight=architecture#first-steps
F468,247,Xilinx/Vitis-AI,"""For minor releases (x.5), users wishing to leverage these architectures have two choices:      Leverage Vitis AI 3.0 for initial evaluation and development.     Build a custom board Petalinux image for their target leveraging the Vitis AI 3.5 runtime and libraries.""",Maintainability,https://xilinx.github.io/Vitis-AI/3.5/html/docs/workflow.html?highlight=architecture#supported-evaluation-targets
F469,247,Xilinx/Vitis-AI,"""Also important is to review the Vitis AI Model Zoo performance metrics which will allow you to contrast the relative performance of each target family.""",Performance Efficiency,https://xilinx.github.io/Vitis-AI/3.5/html/docs/workflow.html?highlight=architecture#first-steps
F470,261,galliot-us/smart-social-distancing,"""The application architecture consists of two main parts that should be run separately; the Dashboard and the Processor.""",Maintainability,https://galliot.us/blog/smart-social-distancing-new-codebase-architecture/
F471,261,galliot-us/smart-social-distancing,"""The Core creates an internal thread to perform the actual processing in a multithreaded fashion. This way, we can ensure that the Core is always listening on the cmd_queue, even while processing videos.""",Performance Efficiency,https://galliot.us/blog/smart-social-distancing-new-codebase-architecture/
F472,261,galliot-us/smart-social-distancing,"""If the Core component is not ready yet, the API will wait until the Core is up and ready and the queues are accessible.""",Reliability,https://galliot.us/blog/smart-social-distancing-new-codebase-architecture/
F473,261,galliot-us/smart-social-distancing,"""We have achieved shippability and accessibility by 'Dockerizing' the Smart Social Distancing application.""","Flexibility, Compatibility",https://galliot.us/blog/smart-social-distancing-new-codebase-architecture/
F474,261,galliot-us/smart-social-distancing,"""Users can access these statistics through the Dashboard at any time.""",Interaction Capability,https://galliot.us/blog/smart-social-distancing-new-codebase-architecture/
F475,259,motion-ai/open-horizon,"""Patterns are composed of services and depend on a successful service build.""",Maintainability,https://github.com/motion-ai/open-horizon/blob/master/docs/PATTERN.md#1-introduction
F476,259,motion-ai/open-horizon,"""There is one implementation of each script with a copy in every base service (e.g. base-ubuntu).""",Maintainability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#introduction
F477,259,motion-ai/open-horizon,"""The service container for the yolo service is built from the base-ubuntu container.""",Maintainability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#example-2-yolo
F478,259,motion-ai/open-horizon,"""Multiple architectures are supported through the build.json configuration file.""",Maintainability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#-buildjson
F479,259,motion-ai/open-horizon,"""Call the hzn_init() function with no arguments and expect a non-zero length string as result.""",Reliability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#step-1---initialize-status
F480,259,motion-ai/open-horizon,"""If the environment variable HZN_EXCHANGE_APIKEY is defined and the pattern is found in the exchange, the details for the pattern will be downloaded and added to the status.""",Reliability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#-hzn_init
F481,259,motion-ai/open-horizon,"""Nodes registered with a pattern may be tested with the make nodes-test command.""",Reliability,https://github.com/motion-ai/open-horizon/blob/master/docs/PATTERN.md#34-test-nodes
F482,259,motion-ai/open-horizon,"""Performs nodes-clean and then purges bluehorizon, horizon, and horizon-cli packages from node.""",Reliability,https://github.com/motion-ai/open-horizon/blob/master/docs/PATTERN.md#46-make-nodes-purge
F483,259,motion-ai/open-horizon,"""These services are all designed on a common pattern to provide a low-latency response to status requests with providing asynchronous updates.""",Performance Efficiency,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#introduction
F484,259,motion-ai/open-horizon,"""When a service container is instantiated on a node it is provided with a set of environment variables by the Open Horizon edge fabric.""",Performance Efficiency,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#introduction
F485,259,motion-ai/open-horizon,"""This service continuously updates the CPU percentage utilization with a value between 0.0 and 100.0.""",Performance Efficiency,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#example-1-cpu
F486,259,motion-ai/open-horizon,"""The build process currently only supports building single Docker container image and uses a single Dockerfile for all architectures.""",Flexibility,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#-dockerfile
F487,259,motion-ai/open-horizon,"""HZN_EXCHANGE_URL - the exchange host URL""",Security,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#introduction
F488,259,motion-ai/open-horizon,"""HZN_ORGANIZATION - the organization for the service (e.g. github@dcmartin.com)""",Security,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#introduction
F489,259,motion-ai/open-horizon,"""The script detects if an executable program exists with the name of the service and .sh appended; if it does exist, the executable is invoked as a background process.""",Functional Suitability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#-service_label
F490,259,motion-ai/open-horizon,"""The last section of the run.sh script utilizes the socat utility to listen on a designated port and respond by invoking the service.sh script.""",Functional Suitability,https://github.com/motion-ai/open-horizon/blob/master/docs/DESIGN.md#step-3---respond-to-http